

## .gitattributes

```
# Auto detect text files and perform LF normalization
* text=auto

```


## .gitignore

```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

.vscode/

```


## AIContext.cjs

```
const fs = require('fs');
const path = require('path');

// Configuration
const outputFile = 'concatenated_files.md';
const dirsToSearch = ['.', './src'];
const excludedDirs = ['node_modules', 'examples', 'assets', '.git'];

// Improved function to check if a path should be excluded
function shouldExclude(filePath) {
  const normalizedPath = path.normalize(filePath);
  
  // Check if the path contains any of the excluded directories
  for (const excludedDir of excludedDirs) {
    // Check various path formats that could match
    if (
      normalizedPath === excludedDir ||
      normalizedPath.startsWith(`${excludedDir}${path.sep}`) ||
      normalizedPath.includes(`${path.sep}${excludedDir}${path.sep}`) ||
      normalizedPath.endsWith(`${path.sep}${excludedDir}`)
    ) {
      return true;
    }
  }
  
  return false;
}

// Function to recursively get all files in a directory
function getAllFiles(dirPath, arrayOfFiles = []) {
  // First check if the directory itself should be excluded
  if (shouldExclude(dirPath)) {
    return arrayOfFiles;
  }

  try {
    const files = fs.readdirSync(dirPath);

    files.forEach(file => {
      const fullPath = path.join(dirPath, file);
      
      // Skip excluded directories
      if (shouldExclude(fullPath)) {
        return;
      }
      
      if (fs.statSync(fullPath).isDirectory()) {
        arrayOfFiles = getAllFiles(fullPath, arrayOfFiles);
      } else {
        arrayOfFiles.push(fullPath);
      }
    });
  } catch (err) {
    console.error(`Error reading directory ${dirPath}: ${err.message}`);
  }

  return arrayOfFiles;
}

// Main function to concatenate files
async function concatenateFiles() {
  try {
    // Get all files from directories to search
    let allFiles = [];
    for (const dir of dirsToSearch) {
      if (fs.existsSync(dir)) {
        allFiles = allFiles.concat(getAllFiles(dir));
      } else {
        console.warn(`Warning: Directory ${dir} does not exist and will be skipped.`);
      }
    }
    
    // Remove duplicates (in case src is a subdirectory of current directory)
    allFiles = [...new Set(allFiles)];
    
    // Sort files for consistent output
    allFiles.sort();
    
    // Create or clear the output file
    fs.writeFileSync(outputFile, '');
    
    console.log(`Starting to process ${allFiles.length} files...`);
    let processedCount = 0;
    
    // Process each file
    for (const filePath of allFiles) {
      try {
        // Read file content
        const content = fs.readFileSync(filePath, 'utf8');
        
        // Write file path and content to output file
        const mdHeader = `\n\n## ${filePath}\n\n\`\`\`\n`;
        const mdFooter = '\n```\n';
        
        fs.appendFileSync(outputFile, mdHeader + content + mdFooter);
        processedCount++;
        
        // Log progress periodically
        if (processedCount % 10 === 0 || processedCount === allFiles.length) {
          console.log(`Progress: ${processedCount}/${allFiles.length} files processed`);
        }
      } catch (err) {
        console.error(`Error processing file ${filePath}: ${err.message}`);
      }
    }
    
    console.log(`\nConcatenation complete! ${processedCount} files were merged into ${outputFile}`);
  } catch (err) {
    console.error(`Error during concatenation: ${err.message}`);
  }
}

// Run the script
concatenateFiles();
```


## README.md

```
# Spine Benchmark

![Spine Benchmark Logo](https://spine.ddstnd.space/logo.png)

**Spine Benchmark** is a performance analysis and visualization tool for Spine animations. It helps developers and designers optimize their Spine animations by providing detailed metrics and visual feedback on various performance aspects.

**Live Demo**: [https://spine.ddstnd.space/](https://spine.ddstnd.space/)

## Features

- **Drag & Drop Interface**: Easily load Spine animations by dropping files or entire folders
- **Comprehensive Analysis**: Get detailed insights on meshes, clipping masks, blend modes, and more
- **Performance Metrics**: Measure and analyze what impacts rendering performance
- **Interactive Visualization**: View and interact with your Spine animation in real-time
- **Cross-Browser Support**: Works in modern browsers with best experience in Chrome
- **Local Processing**: All analysis happens in your browser - no files are uploaded to any server

## Motivation

Spine animations can become performance bottlenecks in games and interactive applications when not optimized properly. This tool was created to help developers:

1. **Identify Optimization Opportunities**: Pinpoint specific elements in your animations that may cause performance issues
2. **Analyze Best Practices**: Understand what makes a Spine animation efficient
3. **Visualize Performance Impact**: See real-time metrics of different animation elements
4. **Educate Teams**: Help artists and developers understand the technical implications of animation choices

## How to Use

### Basic Usage

1. Visit [https://spine.ddstnd.space/](https://spine.ddstnd.space/)
2. Drag and drop your Spine files (JSON/skel, atlas, and image files) onto the drop area
3. The animation will load and the benchmark analysis will be performed automatically
4. Click the document icon to view detailed performance metrics and analysis

### Required Files

To analyze a Spine animation, you need to provide:

- **Skeleton File**: Either a `.json` or `.skel` file containing the skeleton data
- **Atlas File**: A `.atlas` file that defines the texture regions
- **Image Files**: The textures referenced in the atlas file (PNG, JPG, etc.)

You can drop these as individual files or as a folder containing all the required files.

### Understanding the Analysis

The benchmark presents several tabs of analysis:

#### Summary

A high-level overview of your animation's performance characteristics, including:
- Performance score
- Total bones, slots, meshes, etc.
- Identified performance concerns
- Optimization recommendations

#### Mesh Analysis

Detailed breakdown of mesh usage:
- Vertex counts per mesh
- Deformation status
- Bone weights
- Parent mesh connections
- Visual indicators for high-impact meshes

#### Clipping Analysis

Information about clipping masks:
- Number of masks
- Vertex complexity
- Performance impact assessment
- Optimization suggestions

#### Blend Modes

Analysis of blend mode usage:
- Count of non-normal blend modes
- Slots using special blend modes
- Performance impact warnings

#### Skeleton Tree

Visual representation of the skeleton structure:
- Bone hierarchy
- Attachment relationships
- Depth analysis

## Performance Considerations

The benchmark highlights several key performance factors:

### Meshes
- High vertex counts increase GPU load
- Mesh deformations add CPU overhead
- Bone-weighted meshes require additional calculations

### Clipping Masks
- One of the most expensive operations in Spine
- Complex masks (many vertices) significantly impact performance
- Nested clipping increases rendering complexity

### Blend Modes
- Non-normal blend modes cause additional draw calls
- Multiple blend mode changes increase renderer state changes
- Additive and multiply modes have higher overhead

### Bones
- Deep hierarchies increase computation time
- Large numbers of bones impact CPU performance
- Complex constraints add overhead

## Special Thanks and Gratitude

This project wouldn't have been possible without the contributions and support from some amazing individuals:

### Key Contributors

- **[Ivan Popelyshev](https://github.com/ivanpopelyshev)** - For his invaluable expertise in PixiJS and rendering optimizations. Ivan's deep knowledge of WebGL and graphics pipelines helped shape the core rendering analysis capabilities of this tool.

- **[Alexey Koktysh](https://github.com/HorusAK)** - For crucial contributions to the Spine animation processing and performance analysis algorithms. Horus's insights into animation optimization techniques have been instrumental in identifying performance bottlenecks.

- **[Gleb Kaverin](https://github.com/gkavee)** - For his exceptional work on the UI/UX design and implementation of the analysis visualizations. Gleb's commitment to creating intuitive interfaces has made complex performance data accessible to all users.

Their dedication, technical expertise, and passion for the Spine ecosystem have significantly elevated the quality and capabilities of this benchmark tool. We are deeply grateful for their continuous support and contributions to the open-source community.

## Compatibility Notes

- **Spine Version**: Designed for Spine 4.2.x (will automatically convert 4.1.x files but will leave artifacts, you can use https://spine-4-1.ddstnd.space/ for simple preview of such assets)
- **File Drag & Drop**: Works best in Chrome for directory dropping
- **Graphics**: Requires WebGL support in the browser

## Local Development

To run the project locally:

```bash
# Install dependencies
npm install

# Start development server
npm run dev

# Build for production
npm run build
```

## Credits and License

Spine Benchmark is an open-source tool created to help the Spine animation community. It uses:

- [PixiJS](https://pixijs.com/) for WebGL rendering
- [React](https://reactjs.org/) for the user interface
- [Spine Runtime](http://esotericsoftware.com/) for animation processing

Licensed under MIT License - feel free to use, modify and contribute!

## Contributing

Contributions are welcome! If you'd like to improve the benchmark tool:

1. Fork the repository
2. Create a feature branch
3. Implement your changes
4. Submit a pull request

## Contact & Support

If you encounter any issues or have questions about Spine Benchmark:

- Create an issue in this repository
- 
```


## TODO.md

```
- Draw Call Count
- Flush Count
- Посчитать и задокументировать, дешевле переключать альфу или аттачмент (Олег)
- Tint Black
- Проверить каналы экспорта 444
- Скины
- Порядки отрисовки
- Перепроверить число вершин в меше
- Добавить в таблицу меша вершины меша из спайна
- Сравнить альфу 0 и visible по затратам на рендер аттачмента (Никита)
```


## dist\index.html

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Spine Benchmark</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <meta name="description" content="A tool for benchmarking and analyzing Spine animations" />
    <script type="module" crossorigin src="/assets/index-BY6A8S4L.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-CwBqaRJZ.css">
  </head>
  <body>
    <div id="root"></div>
    <div id="toast-container"></div>
    <div id="info-panel-container"></div>
  </body>
</html>
```


## index.html

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Spine Benchmark</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="scrollbars.css">
    <meta name="description" content="A tool for benchmarking and analyzing Spine animations" />
  </head>
  <body>
    <div id="root"></div>
    <div id="toast-container"></div>
    <div id="info-panel-container"></div>
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>
```


## package-lock.json

```
{
  "name": "spine-benchmark",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "spine-benchmark",
      "version": "1.0.0",
      "dependencies": {
        "@esotericsoftware/spine-pixi-v8": "^4.2.74",
        "@paralleldrive/cuid2": "^2.2.2",
        "@vitejs/plugin-react": "^4.3.4",
        "gsap": "^3.12.7",
        "pixi.js": "^8.8.0",
        "react": "^19.0.0",
        "react-dom": "^19.0.0",
        "react-toastify": "^11.0.5",
        "terser": "^5.39.0"
      },
      "devDependencies": {
        "@types/node": "^22.13.5",
        "@types/react": "^19.0.0",
        "@types/react-dom": "^19.0.0",
        "typescript": "^5.7.3",
        "vite": "^6.2.0"
      }
    },
    "node_modules/@ampproject/remapping": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.26.2",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.26.2.tgz",
      "integrity": "sha512-RJlIHRueQgwWitWgF8OdFYGZX328Ax5BCemNGlqHfplnRT9ESi8JkFlvaVYbS+UubVY6dpv87Fs2u5M29iNFVQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.25.9",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.0.0"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.26.8",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.26.8.tgz",
      "integrity": "sha512-oH5UPLMWR3L2wEFLnFJ1TZXqHufiTKAiLfqw5zkhS4dKXLJ10yVztfil/twG8EDTA4F/tvVNw9nOl4ZMslB8rQ==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.26.9",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.26.9.tgz",
      "integrity": "sha512-lWBYIrF7qK5+GjY5Uy+/hEgp8OJWOD/rpy74GplYRhEauvbHDeFB8t5hPOZxCZ0Oxf4Cc36tK51/l3ymJysrKw==",
      "license": "MIT",
      "dependencies": {
        "@ampproject/remapping": "^2.2.0",
        "@babel/code-frame": "^7.26.2",
        "@babel/generator": "^7.26.9",
        "@babel/helper-compilation-targets": "^7.26.5",
        "@babel/helper-module-transforms": "^7.26.0",
        "@babel/helpers": "^7.26.9",
        "@babel/parser": "^7.26.9",
        "@babel/template": "^7.26.9",
        "@babel/traverse": "^7.26.9",
        "@babel/types": "^7.26.9",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.26.9",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.26.9.tgz",
      "integrity": "sha512-kEWdzjOAUMW4hAyrzJ0ZaTOu9OmpyDIQicIh0zg0EEcEkYXZb2TjtBhnHi2ViX7PKwZqF4xwqfAm299/QMP3lg==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.26.9",
        "@babel/types": "^7.26.9",
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.25",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.26.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.26.5.tgz",
      "integrity": "sha512-IXuyn5EkouFJscIDuFF5EsiSolseme1s0CZB+QxVugqJLYmKdxI1VfIBOst0SUu4rnk2Z7kqTwmoO1lp3HIfnA==",
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.26.5",
        "@babel/helper-validator-option": "^7.25.9",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.25.9",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.25.9.tgz",
      "integrity": "sha512-tnUA4RsrmflIM6W6RFTLFSXITtl0wKjgpnLgXyowocVPrbYrLUXSBXDgTs8BlbmIzIdlBySRQjINYs2BAkiLtw==",
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.25.9",
        "@babel/types": "^7.25.9"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.26.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.26.0.tgz",
      "integrity": "sha512-xO+xu6B5K2czEnQye6BHA7DolFFmS3LB7stHZFaOLb1pAwO1HWLS8fXA+eh0A2yIvltPVmx3eNNDBJA2SLHXFw==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.25.9",
        "@babel/helper-validator-identifier": "^7.25.9",
        "@babel/traverse": "^7.25.9"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.26.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.26.5.tgz",
      "integrity": "sha512-RS+jZcRdZdRFzMyr+wcsaqOmld1/EqTghfaBGQQd/WnRdzdlvSZ//kF7U8VQTxf1ynZ4cjUcYgjVGx13ewNPMg==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.25.9",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.25.9.tgz",
      "integrity": "sha512-4A/SCr/2KLd5jrtOMFzaKjVtAei3+2r/NChoBNoZ3EyP/+GlhoaEGoWOZUmFmoITP7zOJyHIMm+DYRd8o3PvHA==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.25.9",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.25.9.tgz",
      "integrity": "sha512-Ed61U6XJc3CVRfkERJWDz4dJwKe7iLmmJsbOGu9wSloNSFttHV0I8g6UAgb7qnK5ly5bGLPd4oXZlxCdANBOWQ==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.25.9",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.25.9.tgz",
      "integrity": "sha512-e/zv1co8pp55dNdEcCynfj9X7nyUKUXoUEwfXqaZt0omVOmDe9oOTdKStH4GmAw6zxMFs50ZayuMfHDKlO7Tfw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.26.9",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.26.9.tgz",
      "integrity": "sha512-Mz/4+y8udxBKdmzt/UjPACs4G3j5SshJJEFFKxlCGPydG4JAHXxjWjAwjd09tf6oINvl1VfMJo+nB7H2YKQ0dA==",
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.26.9",
        "@babel/types": "^7.26.9"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.26.9",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.26.9.tgz",
      "integrity": "sha512-81NWa1njQblgZbQHxWHpxxCzNsa3ZwvFqpUg7P+NNUU6f3UU2jBEg4OlF/J6rl8+PQGh1q6/zWScd001YwcA5A==",
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.26.9"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-self": {
      "version": "7.25.9",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-self/-/plugin-transform-react-jsx-self-7.25.9.tgz",
      "integrity": "sha512-y8quW6p0WHkEhmErnfe58r7x0A70uKphQm8Sp8cV7tjNQwK56sNVK0M73LK3WuYmsuyrftut4xAkjjgU0twaMg==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.25.9"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-source": {
      "version": "7.25.9",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-source/-/plugin-transform-react-jsx-source-7.25.9.tgz",
      "integrity": "sha512-+iqjT8xmXhhYv4/uiYd8FNQsraMFZIfxVSqxxVSZP0WbbSAWvBXAul0m/zu+7Vv4O/3WtApy9pmaTMiumEZgfg==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.25.9"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.26.9",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.26.9.tgz",
      "integrity": "sha512-qyRplbeIpNZhmzOysF/wFMuP9sctmh2cFzRAZOn1YapxBsE1i9bJIY586R/WBLfLcmcBlM8ROBiQURnnNy+zfA==",
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.26.2",
        "@babel/parser": "^7.26.9",
        "@babel/types": "^7.26.9"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.26.9",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.26.9.tgz",
      "integrity": "sha512-ZYW7L+pL8ahU5fXmNbPF+iZFHCv5scFak7MZ9bwaRPLUhHh7QQEMjZUg0HevihoqCM5iSYHN61EyCoZvqC+bxg==",
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.26.2",
        "@babel/generator": "^7.26.9",
        "@babel/parser": "^7.26.9",
        "@babel/template": "^7.26.9",
        "@babel/types": "^7.26.9",
        "debug": "^4.3.1",
        "globals": "^11.1.0"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.26.9",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.26.9.tgz",
      "integrity": "sha512-Y3IR1cRnOxOCDvMmNiym7XpXQ93iGDDPHx+Zj+NM+rg0fBaShfQLkg+hKPaZCEvg5N/LeCo4+Rj/i3FuJsIQaw==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.25.9",
        "@babel/helper-validator-identifier": "^7.25.9"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.25.0.tgz",
      "integrity": "sha512-O7vun9Sf8DFjH2UtqK8Ku3LkquL9SZL8OLY1T5NZkA34+wG3OQF7cl4Ql8vdNzM6fzBbYfLaiRLIOZ+2FOCgBQ==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.25.0.tgz",
      "integrity": "sha512-PTyWCYYiU0+1eJKmw21lWtC+d08JDZPQ5g+kFyxP0V+es6VPPSUhM6zk8iImp2jbV6GwjX4pap0JFbUQN65X1g==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.25.0.tgz",
      "integrity": "sha512-grvv8WncGjDSyUBjN9yHXNt+cq0snxXbDxy5pJtzMKGmmpPxeAmAhWxXI+01lU5rwZomDgD3kJwulEnhTRUd6g==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.25.0.tgz",
      "integrity": "sha512-m/ix7SfKG5buCnxasr52+LI78SQ+wgdENi9CqyCXwjVR2X4Jkz+BpC3le3AoBPYTC9NHklwngVXvbJ9/Akhrfg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.25.0.tgz",
      "integrity": "sha512-mVwdUb5SRkPayVadIOI78K7aAnPamoeFR2bT5nszFUZ9P8UpK4ratOdYbZZXYSqPKMHfS1wdHCJk1P1EZpRdvw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.25.0.tgz",
      "integrity": "sha512-DgDaYsPWFTS4S3nWpFcMn/33ZZwAAeAFKNHNa1QN0rI4pUjgqf0f7ONmXf6d22tqTY+H9FNdgeaAa+YIFUn2Rg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.25.0.tgz",
      "integrity": "sha512-VN4ocxy6dxefN1MepBx/iD1dH5K8qNtNe227I0mnTRjry8tj5MRk4zprLEdG8WPyAPb93/e4pSgi1SoHdgOa4w==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.25.0.tgz",
      "integrity": "sha512-mrSgt7lCh07FY+hDD1TxiTyIHyttn6vnjesnPoVDNmDfOmggTLXRv8Id5fNZey1gl/V2dyVK1VXXqVsQIiAk+A==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.25.0.tgz",
      "integrity": "sha512-vkB3IYj2IDo3g9xX7HqhPYxVkNQe8qTK55fraQyTzTX/fxaDtXiEnavv9geOsonh2Fd2RMB+i5cbhu2zMNWJwg==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.25.0.tgz",
      "integrity": "sha512-9QAQjTWNDM/Vk2bgBl17yWuZxZNQIF0OUUuPZRKoDtqF2k4EtYbpyiG5/Dk7nqeK6kIJWPYldkOcBqjXjrUlmg==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.25.0.tgz",
      "integrity": "sha512-43ET5bHbphBegyeqLb7I1eYn2P/JYGNmzzdidq/w0T8E2SsYL1U6un2NFROFRg1JZLTzdCoRomg8Rvf9M6W6Gg==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.25.0.tgz",
      "integrity": "sha512-fC95c/xyNFueMhClxJmeRIj2yrSMdDfmqJnyOY4ZqsALkDrrKJfIg5NTMSzVBr5YW1jf+l7/cndBfP3MSDpoHw==",
      "cpu": [
        "loong64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.25.0.tgz",
      "integrity": "sha512-nkAMFju7KDW73T1DdH7glcyIptm95a7Le8irTQNO/qtkoyypZAnjchQgooFUDQhNAy4iu08N79W4T4pMBwhPwQ==",
      "cpu": [
        "mips64el"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.25.0.tgz",
      "integrity": "sha512-NhyOejdhRGS8Iwv+KKR2zTq2PpysF9XqY+Zk77vQHqNbo/PwZCzB5/h7VGuREZm1fixhs4Q/qWRSi5zmAiO4Fw==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.25.0.tgz",
      "integrity": "sha512-5S/rbP5OY+GHLC5qXp1y/Mx//e92L1YDqkiBbO9TQOvuFXM+iDqUNG5XopAnXoRH3FjIUDkeGcY1cgNvnXp/kA==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.25.0.tgz",
      "integrity": "sha512-XM2BFsEBz0Fw37V0zU4CXfcfuACMrppsMFKdYY2WuTS3yi8O1nFOhil/xhKTmE1nPmVyvQJjJivgDT+xh8pXJA==",
      "cpu": [
        "s390x"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.25.0.tgz",
      "integrity": "sha512-9yl91rHw/cpwMCNytUDxwj2XjFpxML0y9HAOH9pNVQDpQrBxHy01Dx+vaMu0N1CKa/RzBD2hB4u//nfc+Sd3Cw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-arm64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.25.0.tgz",
      "integrity": "sha512-RuG4PSMPFfrkH6UwCAqBzauBWTygTvb1nxWasEJooGSJ/NwRw7b2HOwyRTQIU97Hq37l3npXoZGYMy3b3xYvPw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.25.0.tgz",
      "integrity": "sha512-jl+qisSB5jk01N5f7sPCsBENCOlPiS/xptD5yxOx2oqQfyourJwIKLRA2yqWdifj3owQZCL2sn6o08dBzZGQzA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-arm64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.25.0.tgz",
      "integrity": "sha512-21sUNbq2r84YE+SJDfaQRvdgznTD8Xc0oc3p3iW/a1EVWeNj/SdUCbm5U0itZPQYRuRTW20fPMWMpcrciH2EJw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.25.0.tgz",
      "integrity": "sha512-2gwwriSMPcCFRlPlKx3zLQhfN/2WjJ2NSlg5TKLQOJdV0mSxIcYNTMhk3H3ulL/cak+Xj0lY1Ym9ysDV1igceg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.25.0.tgz",
      "integrity": "sha512-bxI7ThgLzPrPz484/S9jLlvUAHYMzy6I0XiU1ZMeAEOBcS0VePBFxh1JjTQt3Xiat5b6Oh4x7UC7IwKQKIJRIg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.25.0.tgz",
      "integrity": "sha512-ZUAc2YK6JW89xTbXvftxdnYy3m4iHIkDtK3CLce8wg8M2L+YZhIvO1DKpxrd0Yr59AeNNkTiic9YLf6FTtXWMw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.25.0.tgz",
      "integrity": "sha512-eSNxISBu8XweVEWG31/JzjkIGbGIJN/TrRoiSVZwZ6pkC6VX4Im/WV2cz559/TXLcYbcrDN8JtKgd9DJVIo8GA==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.25.0.tgz",
      "integrity": "sha512-ZENoHJBxA20C2zFzh6AI4fT6RraMzjYw4xKWemRTRmRVtN9c5DcH9r/f2ihEkMjOW5eGgrwCslG/+Y/3bL+DHQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esotericsoftware/spine-core": {
      "version": "4.2.74",
      "resolved": "https://registry.npmjs.org/@esotericsoftware/spine-core/-/spine-core-4.2.74.tgz",
      "integrity": "sha512-HdEm7702yT7tZyBwX8CeB1+UhBLJRLW9+mffBQIEllr+XzwiawrRalV5RneKwhpygs8PYVqlZbpeWCPlZEH22A==",
      "license": "LicenseRef-LICENSE"
    },
    "node_modules/@esotericsoftware/spine-pixi-v8": {
      "version": "4.2.74",
      "resolved": "https://registry.npmjs.org/@esotericsoftware/spine-pixi-v8/-/spine-pixi-v8-4.2.74.tgz",
      "integrity": "sha512-f90lkQt0hcmSeQI7epIT8H22JsA9QZu5Vsv4Bb5Fop3sCfPItY8frN9qduWrMt/tmGl7E2OT3gjvQJULIjdnNQ==",
      "license": "LicenseRef-LICENSE",
      "dependencies": {
        "@esotericsoftware/spine-core": "4.2.74"
      },
      "peerDependencies": {
        "pixi.js": "^8.4.0"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.8",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.8.tgz",
      "integrity": "sha512-imAbBGkb+ebQyxKgzv5Hu2nmROxoDOXHh80evxdoXNOrvAnVx7zimzc1Oo5h9RlfV4vPXaE2iM5pOFbvOCClWA==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/set-array": "^1.2.1",
        "@jridgewell/sourcemap-codec": "^1.4.10",
        "@jridgewell/trace-mapping": "^0.3.24"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/set-array": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/@jridgewell/set-array/-/set-array-1.2.1.tgz",
      "integrity": "sha512-R8gLRTZeyp03ymzP/6Lil/28tGeGEzhx1q2k703KGWRAI1VdvPIXdG70VJc2pAMw3NA6JKL5hhFu1sJX0Mnn/A==",
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/source-map": {
      "version": "0.3.6",
      "resolved": "https://registry.npmjs.org/@jridgewell/source-map/-/source-map-0.3.6.tgz",
      "integrity": "sha512-1ZJTZebgqllO79ue2bm3rIGud/bOe0pP5BjSRCRxxYkEZS8STV7zN84UBbiYu7jy+eCKSnVIUgoWWE/tt+shMQ==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.25"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.0.tgz",
      "integrity": "sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==",
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.25",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.25.tgz",
      "integrity": "sha512-vNk6aEwybGtawWmy/PzwnGDOjCkLWSD2wqvjGGAgOAwCGWySYXfYoxt00IJkTF+8Lb57DwOb3Aa0o9CApepiYQ==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@noble/hashes": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/@noble/hashes/-/hashes-1.5.0.tgz",
      "integrity": "sha512-1j6kQFb7QRru7eKN3ZDvRcP13rugwdxZqCjbiAVZfIJwgj2A65UmT4TgARXGlXgnRkORLTDTrO19ZErt7+QXgA==",
      "engines": {
        "node": "^14.21.3 || >=16"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      }
    },
    "node_modules/@paralleldrive/cuid2": {
      "version": "2.2.2",
      "resolved": "https://registry.npmjs.org/@paralleldrive/cuid2/-/cuid2-2.2.2.tgz",
      "integrity": "sha512-ZOBkgDwEdoYVlSeRbYYXs0S9MejQofiVYoTbKzy/6GQa39/q5tQU2IX46+shYnUkpEl3wc+J6wRlar7r2EK2xA==",
      "dependencies": {
        "@noble/hashes": "^1.1.5"
      }
    },
    "node_modules/@pixi/colord": {
      "version": "2.9.6",
      "resolved": "https://registry.npmjs.org/@pixi/colord/-/colord-2.9.6.tgz",
      "integrity": "sha512-nezytU2pw587fQstUu1AsJZDVEynjskwOL+kibwcdxsMBFqPsFFNA7xl0ii/gXuDi6M0xj3mfRJj8pBSc2jCfA=="
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.34.8.tgz",
      "integrity": "sha512-q217OSE8DTp8AFHuNHXo0Y86e1wtlfVrXiAlwkIvGRQv9zbc6mE3sjIVfwI8sYUyNxwOg0j/Vm1RKM04JcWLJw==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.34.8.tgz",
      "integrity": "sha512-Gigjz7mNWaOL9wCggvoK3jEIUUbGul656opstjaUSGC3eT0BM7PofdAJaBfPFWWkXNVAXbaQtC99OCg4sJv70Q==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.34.8.tgz",
      "integrity": "sha512-02rVdZ5tgdUNRxIUrFdcMBZQoaPMrxtwSb+/hOfBdqkatYHR3lZ2A2EGyHq2sGOd0Owk80oV3snlDASC24He3Q==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.34.8.tgz",
      "integrity": "sha512-qIP/elwR/tq/dYRx3lgwK31jkZvMiD6qUtOycLhTzCvrjbZ3LjQnEM9rNhSGpbLXVJYQ3rq39A6Re0h9tU2ynw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.34.8.tgz",
      "integrity": "sha512-IQNVXL9iY6NniYbTaOKdrlVP3XIqazBgJOVkddzJlqnCpRi/yAeSOa8PLcECFSQochzqApIOE1GHNu3pCz+BDA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.34.8.tgz",
      "integrity": "sha512-TYXcHghgnCqYFiE3FT5QwXtOZqDj5GmaFNTNt3jNC+vh22dc/ukG2cG+pi75QO4kACohZzidsq7yKTKwq/Jq7Q==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.34.8.tgz",
      "integrity": "sha512-A4iphFGNkWRd+5m3VIGuqHnG3MVnqKe7Al57u9mwgbyZ2/xF9Jio72MaY7xxh+Y87VAHmGQr73qoKL9HPbXj1g==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.34.8.tgz",
      "integrity": "sha512-S0lqKLfTm5u+QTxlFiAnb2J/2dgQqRy/XvziPtDd1rKZFXHTyYLoVL58M/XFwDI01AQCDIevGLbQrMAtdyanpA==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.34.8.tgz",
      "integrity": "sha512-jpz9YOuPiSkL4G4pqKrus0pn9aYwpImGkosRKwNi+sJSkz+WU3anZe6hi73StLOQdfXYXC7hUfsQlTnjMd3s1A==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.34.8.tgz",
      "integrity": "sha512-KdSfaROOUJXgTVxJNAZ3KwkRc5nggDk+06P6lgi1HLv1hskgvxHUKZ4xtwHkVYJ1Rep4GNo+uEfycCRRxht7+Q==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loongarch64-gnu": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loongarch64-gnu/-/rollup-linux-loongarch64-gnu-4.34.8.tgz",
      "integrity": "sha512-NyF4gcxwkMFRjgXBM6g2lkT58OWztZvw5KkV2K0qqSnUEqCVcqdh2jN4gQrTn/YUpAcNKyFHfoOZEer9nwo6uQ==",
      "cpu": [
        "loong64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-powerpc64le-gnu": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-powerpc64le-gnu/-/rollup-linux-powerpc64le-gnu-4.34.8.tgz",
      "integrity": "sha512-LMJc999GkhGvktHU85zNTDImZVUCJ1z/MbAJTnviiWmmjyckP5aQsHtcujMjpNdMZPT2rQEDBlJfubhs3jsMfw==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.34.8.tgz",
      "integrity": "sha512-xAQCAHPj8nJq1PI3z8CIZzXuXCstquz7cIOL73HHdXiRcKk8Ywwqtx2wrIy23EcTn4aZ2fLJNBB8d0tQENPCmw==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.34.8.tgz",
      "integrity": "sha512-DdePVk1NDEuc3fOe3dPPTb+rjMtuFw89gw6gVWxQFAuEqqSdDKnrwzZHrUYdac7A7dXl9Q2Vflxpme15gUWQFA==",
      "cpu": [
        "s390x"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.34.8.tgz",
      "integrity": "sha512-8y7ED8gjxITUltTUEJLQdgpbPh1sUQ0kMTmufRF/Ns5tI9TNMNlhWtmPKKHCU0SilX+3MJkZ0zERYYGIVBYHIA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.34.8.tgz",
      "integrity": "sha512-SCXcP0ZpGFIe7Ge+McxY5zKxiEI5ra+GT3QRxL0pMMtxPfpyLAKleZODi1zdRHkz5/BhueUrYtYVgubqe9JBNQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.34.8.tgz",
      "integrity": "sha512-YHYsgzZgFJzTRbth4h7Or0m5O74Yda+hLin0irAIobkLQFRQd1qWmnoVfwmKm9TXIZVAD0nZ+GEb2ICicLyCnQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.34.8.tgz",
      "integrity": "sha512-r3NRQrXkHr4uWy5TOjTpTYojR9XmF0j/RYgKCef+Ag46FWUTltm5ziticv8LdNsDMehjJ543x/+TJAek/xBA2w==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.34.8.tgz",
      "integrity": "sha512-U0FaE5O1BCpZSeE6gBl3c5ObhePQSfk9vDRToMmTkbhCOgW4jqvtS5LGyQ76L1fH8sM0keRp4uDTsbjiUyjk0g==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@types/babel__core": {
      "version": "7.20.5",
      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
      "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "node_modules/@types/babel__generator": {
      "version": "7.6.8",
      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.6.8.tgz",
      "integrity": "sha512-ASsj+tpEDsEiFr1arWrlN6V3mdfjRMZt6LtK/Vp/kreFLnr5QH5+DhvD5nINYZXzwJvXeGq+05iUXcAzVrqWtw==",
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__template": {
      "version": "7.4.4",
      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
      "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__traverse": {
      "version": "7.20.6",
      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.20.6.tgz",
      "integrity": "sha512-r1bzfrm0tomOI8g1SzvCaQHo6Lcv6zu0EA+W2kHrt8dyrHQxGzBBL4kdkzIS+jBMV+EYcMAEAqXqYaLJq5rOZg==",
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.20.7"
      }
    },
    "node_modules/@types/css-font-loading-module": {
      "version": "0.0.12",
      "resolved": "https://registry.npmjs.org/@types/css-font-loading-module/-/css-font-loading-module-0.0.12.tgz",
      "integrity": "sha512-x2tZZYkSxXqWvTDgveSynfjq/T2HyiZHXb00j/+gy19yp70PHCizM48XFdjBCWH7eHBD0R5i/pw9yMBP/BH5uA=="
    },
    "node_modules/@types/earcut": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@types/earcut/-/earcut-2.1.4.tgz",
      "integrity": "sha512-qp3m9PPz4gULB9MhjGID7wpo3gJ4bTGXm7ltNDsmOvsPduTeHp8wSW9YckBj3mljeOh4F0m2z/0JKAALRKbmLQ=="
    },
    "node_modules/@types/estree": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.6.tgz",
      "integrity": "sha512-AYnb1nQyY49te+VRAVgmzfcgjYS91mY5P0TKUDCLEM+gNnA+3T6rWITXRLYCpahpqSQbN5cE+gHpnPyXjHWxcw==",
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "22.13.5",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.13.5.tgz",
      "integrity": "sha512-+lTU0PxZXn0Dr1NBtC7Y8cR21AJr87dLLU953CWA6pMxxv/UDc7jYAY90upcrie1nRcD6XNG5HOYEDtgW5TxAg==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.20.0"
      }
    },
    "node_modules/@types/react": {
      "version": "19.0.10",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-19.0.10.tgz",
      "integrity": "sha512-JuRQ9KXLEjaUNjTWpzuR231Z2WpIwczOkBEIvbHNCzQefFIT0L8IqE6NV6ULLyC1SI/i234JnDoMkfg+RjQj2g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "csstype": "^3.0.2"
      }
    },
    "node_modules/@types/react-dom": {
      "version": "19.0.4",
      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.0.4.tgz",
      "integrity": "sha512-4fSQ8vWFkg+TGhePfUzVmat3eC14TXYSsiiDSLI0dVLsrm9gZFABjPy/Qu6TKgl1tq1Bu1yDsuQgY3A3DOjCcg==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^19.0.0"
      }
    },
    "node_modules/@vitejs/plugin-react": {
      "version": "4.3.4",
      "resolved": "https://registry.npmjs.org/@vitejs/plugin-react/-/plugin-react-4.3.4.tgz",
      "integrity": "sha512-SCCPBJtYLdE8PX/7ZQAs1QAZ8Jqwih+0VBLum1EGqmCCQal+MIUqLCzj3ZUy8ufbC0cAM4LRlSTm7IQJwWT4ug==",
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.26.0",
        "@babel/plugin-transform-react-jsx-self": "^7.25.9",
        "@babel/plugin-transform-react-jsx-source": "^7.25.9",
        "@types/babel__core": "^7.20.5",
        "react-refresh": "^0.14.2"
      },
      "engines": {
        "node": "^14.18.0 || >=16.0.0"
      },
      "peerDependencies": {
        "vite": "^4.2.0 || ^5.0.0 || ^6.0.0"
      }
    },
    "node_modules/@webgpu/types": {
      "version": "0.1.52",
      "resolved": "https://registry.npmjs.org/@webgpu/types/-/types-0.1.52.tgz",
      "integrity": "sha512-eI883Nlag2hGIkhXxAnq8s4APpqXWuPL3Gbn2ghiU12UjLvfCbVqHK4XfXl3eLRTatqcMmeK7jws7IwWsGfbzw=="
    },
    "node_modules/@xmldom/xmldom": {
      "version": "0.8.10",
      "resolved": "https://registry.npmjs.org/@xmldom/xmldom/-/xmldom-0.8.10.tgz",
      "integrity": "sha512-2WALfTl4xo2SkGCYRt6rDTFfk9R1czmBvUQy12gK2KuRKIpWEhcbbzy8EZXtz/jkRqHX8bFEc6FC1HjX4TUWYw==",
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/acorn": {
      "version": "8.14.1",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.14.1.tgz",
      "integrity": "sha512-OvQ/2pUDKmgfCg++xsTX1wGxfTaszcHVcTctW4UJB4hibJx2HXxxO5UmVgyjMa+ZDsiaf5wWLXYpRWMmBI0QHg==",
      "license": "MIT",
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/browserslist": {
      "version": "4.24.4",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.24.4.tgz",
      "integrity": "sha512-KDi1Ny1gSePi1vm0q4oxSF8b4DR44GF4BbmS2YdhPLOEqd8pDviZOGH/GsmRwoWJ2+5Lr085X7naowMwKHDG1A==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "caniuse-lite": "^1.0.30001688",
        "electron-to-chromium": "^1.5.73",
        "node-releases": "^2.0.19",
        "update-browserslist-db": "^1.1.1"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/buffer-from": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz",
      "integrity": "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==",
      "license": "MIT"
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001703",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001703.tgz",
      "integrity": "sha512-kRlAGTRWgPsOj7oARC9m1okJEXdL/8fekFVcxA8Hl7GH4r/sN4OJn/i6Flde373T50KS7Y37oFbMwlE8+F42kQ==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/clsx": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/clsx/-/clsx-2.1.1.tgz",
      "integrity": "sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/commander": {
      "version": "2.20.3",
      "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
      "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==",
      "license": "MIT"
    },
    "node_modules/convert-source-map": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
      "license": "MIT"
    },
    "node_modules/csstype": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.1.3.tgz",
      "integrity": "sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/debug": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.0.tgz",
      "integrity": "sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/earcut": {
      "version": "2.2.4",
      "resolved": "https://registry.npmjs.org/earcut/-/earcut-2.2.4.tgz",
      "integrity": "sha512-/pjZsA1b4RPHbeWZQn66SWS8nZZWLQQ23oE3Eam7aroEFGEvwKAsJfZ9ytiEMycfzXWpca4FA9QIOehf7PocBQ=="
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.114",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.114.tgz",
      "integrity": "sha512-DFptFef3iktoKlFQK/afbo274/XNWD00Am0xa7M8FZUepHlHT8PEuiNBoRfFHbH1okqN58AlhbJ4QTkcnXorjA==",
      "license": "ISC"
    },
    "node_modules/esbuild": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.25.0.tgz",
      "integrity": "sha512-BXq5mqc8ltbaN34cDqWuYKyNhX8D/Z0J1xdtdQ8UcIIIyJyz+ZMKUt58tF3SrZ85jcfN/PZYhjR5uDQAYNVbuw==",
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=18"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.25.0",
        "@esbuild/android-arm": "0.25.0",
        "@esbuild/android-arm64": "0.25.0",
        "@esbuild/android-x64": "0.25.0",
        "@esbuild/darwin-arm64": "0.25.0",
        "@esbuild/darwin-x64": "0.25.0",
        "@esbuild/freebsd-arm64": "0.25.0",
        "@esbuild/freebsd-x64": "0.25.0",
        "@esbuild/linux-arm": "0.25.0",
        "@esbuild/linux-arm64": "0.25.0",
        "@esbuild/linux-ia32": "0.25.0",
        "@esbuild/linux-loong64": "0.25.0",
        "@esbuild/linux-mips64el": "0.25.0",
        "@esbuild/linux-ppc64": "0.25.0",
        "@esbuild/linux-riscv64": "0.25.0",
        "@esbuild/linux-s390x": "0.25.0",
        "@esbuild/linux-x64": "0.25.0",
        "@esbuild/netbsd-arm64": "0.25.0",
        "@esbuild/netbsd-x64": "0.25.0",
        "@esbuild/openbsd-arm64": "0.25.0",
        "@esbuild/openbsd-x64": "0.25.0",
        "@esbuild/sunos-x64": "0.25.0",
        "@esbuild/win32-arm64": "0.25.0",
        "@esbuild/win32-ia32": "0.25.0",
        "@esbuild/win32-x64": "0.25.0"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/globals": {
      "version": "11.12.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-11.12.0.tgz",
      "integrity": "sha512-WOBp/EEGUiIsJSp7wcv/y6MO+lV9UoncWqxuFfm8eBwzWNgyfBd6Gz+IeKQ9jCmyhoH99g15M3T+QaVHFjizVA==",
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/gsap": {
      "version": "3.12.7",
      "resolved": "https://registry.npmjs.org/gsap/-/gsap-3.12.7.tgz",
      "integrity": "sha512-V4GsyVamhmKefvcAKaoy0h6si0xX7ogwBoBSs2CTJwt7luW0oZzC0LhdkyuKV8PJAXr7Yaj8pMjCKD4GJ+eEMg==",
      "license": "Standard 'no charge' license: https://gsap.com/standard-license. Club GSAP members get more: https://gsap.com/licensing/. Why GreenSock doesn't employ an MIT license: https://gsap.com/why-license/"
    },
    "node_modules/ismobilejs": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ismobilejs/-/ismobilejs-1.1.1.tgz",
      "integrity": "sha512-VaFW53yt8QO61k2WJui0dHf4SlL8lxBofUuUmwBo0ljPk0Drz2TiuDW4jo3wDcv41qy/SxrJ+VAzJ/qYqsmzRw=="
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "license": "MIT"
    },
    "node_modules/jsesc": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.8",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.8.tgz",
      "integrity": "sha512-WNLf5Sd8oZxOm+TzppcYk8gVOgP+l58xNy58D0nbUnOxOWRWvlcCV4kUF7ltmI6PsrLl/BgKEyS4mqsGChFN0w==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/node-releases": {
      "version": "2.0.19",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.19.tgz",
      "integrity": "sha512-xxOWJsBKtzAq7DY0J+DTzuz58K8e7sJbdgwkbMWQe8UYB6ekmsQ45q0M/tJDsGaZmbC+l7n57UV8Hl5tHxO9uw==",
      "license": "MIT"
    },
    "node_modules/parse-svg-path": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/parse-svg-path/-/parse-svg-path-0.1.2.tgz",
      "integrity": "sha512-JyPSBnkTJ0AI8GGJLfMXvKq42cj5c006fnLz6fXy6zfoVjJizi8BNTpu8on8ziI1cKy9d9DGNuY17Ce7wuejpQ=="
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "license": "ISC"
    },
    "node_modules/pixi.js": {
      "version": "8.8.0",
      "resolved": "https://registry.npmjs.org/pixi.js/-/pixi.js-8.8.0.tgz",
      "integrity": "sha512-0xW8tKa+uF28mi1SwvnNscMpYJSQrqLN7jJs6Ore37FZoXmIRzQNrGA6drpHDVTuEmoqJlSiGLCk5cUgz3ODgQ==",
      "license": "MIT",
      "dependencies": {
        "@pixi/colord": "^2.9.6",
        "@types/css-font-loading-module": "^0.0.12",
        "@types/earcut": "^2.1.4",
        "@webgpu/types": "^0.1.40",
        "@xmldom/xmldom": "^0.8.10",
        "earcut": "^2.2.4",
        "eventemitter3": "^5.0.1",
        "ismobilejs": "^1.1.1",
        "parse-svg-path": "^0.1.2"
      }
    },
    "node_modules/pixi.js/node_modules/eventemitter3": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/eventemitter3/-/eventemitter3-5.0.1.tgz",
      "integrity": "sha512-GWkBvjiSZK87ELrYOSESUYeVIc9mvLLf/nXalMOS5dYrgZq9o5OVkbZAVM06CVxYsCwH9BDZFPlQTlPA1j4ahA=="
    },
    "node_modules/postcss": {
      "version": "8.5.3",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.3.tgz",
      "integrity": "sha512-dle9A3yYxlBSrt8Fu+IpjGT8SY8hN0mlaA6GY8t0P5PjIOZemULz/E2Bnm/2dcUOena75OTNkHI76uZBNUUq3A==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.8",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/react": {
      "version": "19.0.0",
      "resolved": "https://registry.npmjs.org/react/-/react-19.0.0.tgz",
      "integrity": "sha512-V8AVnmPIICiWpGfm6GLzCR/W5FXLchHop40W4nXBmdlEceh16rCN8O8LNWm5bh5XUX91fh7KpA+W0TgMKmgTpQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.0.0",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.0.0.tgz",
      "integrity": "sha512-4GV5sHFG0e/0AD4X+ySy6UJd3jVl1iNsNHdpad0qhABJ11twS3TTBnseqsKurKcsNqCEFeGL3uLpVChpIO3QfQ==",
      "license": "MIT",
      "dependencies": {
        "scheduler": "^0.25.0"
      },
      "peerDependencies": {
        "react": "^19.0.0"
      }
    },
    "node_modules/react-refresh": {
      "version": "0.14.2",
      "resolved": "https://registry.npmjs.org/react-refresh/-/react-refresh-0.14.2.tgz",
      "integrity": "sha512-jCvmsr+1IUSMUyzOkRcvnVbX3ZYC6g9TDrDbFuFmRDq7PD4yaGbLKNQL6k2jnArV8hjYxh7hVhAZB6s9HDGpZA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-toastify": {
      "version": "11.0.5",
      "resolved": "https://registry.npmjs.org/react-toastify/-/react-toastify-11.0.5.tgz",
      "integrity": "sha512-EpqHBGvnSTtHYhCPLxML05NLY2ZX0JURbAdNYa6BUkk+amz4wbKBQvoKQAB0ardvSarUBuY4Q4s1sluAzZwkmA==",
      "license": "MIT",
      "dependencies": {
        "clsx": "^2.1.1"
      },
      "peerDependencies": {
        "react": "^18 || ^19",
        "react-dom": "^18 || ^19"
      }
    },
    "node_modules/rollup": {
      "version": "4.34.8",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.34.8.tgz",
      "integrity": "sha512-489gTVMzAYdiZHFVA/ig/iYFllCcWFHMvUHI1rpFmkoUtRlQxqh6/yiNqnYibjMZ2b/+FUQwldG+aLsEt6bglQ==",
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.6"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.34.8",
        "@rollup/rollup-android-arm64": "4.34.8",
        "@rollup/rollup-darwin-arm64": "4.34.8",
        "@rollup/rollup-darwin-x64": "4.34.8",
        "@rollup/rollup-freebsd-arm64": "4.34.8",
        "@rollup/rollup-freebsd-x64": "4.34.8",
        "@rollup/rollup-linux-arm-gnueabihf": "4.34.8",
        "@rollup/rollup-linux-arm-musleabihf": "4.34.8",
        "@rollup/rollup-linux-arm64-gnu": "4.34.8",
        "@rollup/rollup-linux-arm64-musl": "4.34.8",
        "@rollup/rollup-linux-loongarch64-gnu": "4.34.8",
        "@rollup/rollup-linux-powerpc64le-gnu": "4.34.8",
        "@rollup/rollup-linux-riscv64-gnu": "4.34.8",
        "@rollup/rollup-linux-s390x-gnu": "4.34.8",
        "@rollup/rollup-linux-x64-gnu": "4.34.8",
        "@rollup/rollup-linux-x64-musl": "4.34.8",
        "@rollup/rollup-win32-arm64-msvc": "4.34.8",
        "@rollup/rollup-win32-ia32-msvc": "4.34.8",
        "@rollup/rollup-win32-x64-msvc": "4.34.8",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/scheduler": {
      "version": "0.25.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.25.0.tgz",
      "integrity": "sha512-xFVuu11jh+xcO7JOAGJNOXld8/TcEHK/4CituBUeUb5hqxJLj9YuemAEuvm9gQ/+pgXYfbQuqAkiYu+u7YEsNA==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/source-map": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-support": {
      "version": "0.5.21",
      "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.21.tgz",
      "integrity": "sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==",
      "license": "MIT",
      "dependencies": {
        "buffer-from": "^1.0.0",
        "source-map": "^0.6.0"
      }
    },
    "node_modules/terser": {
      "version": "5.39.0",
      "resolved": "https://registry.npmjs.org/terser/-/terser-5.39.0.tgz",
      "integrity": "sha512-LBAhFyLho16harJoWMg/nZsQYgTrg5jXOn2nCYjRUcZZEdE3qa2zb8QEDRUGVZBW4rlazf2fxkg8tztybTaqWw==",
      "license": "BSD-2-Clause",
      "dependencies": {
        "@jridgewell/source-map": "^0.3.3",
        "acorn": "^8.8.2",
        "commander": "^2.20.0",
        "source-map-support": "~0.5.20"
      },
      "bin": {
        "terser": "bin/terser"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/typescript": {
      "version": "5.7.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.7.3.tgz",
      "integrity": "sha512-84MVSjMEHP+FQRPy3pX9sTVV/INIex71s9TL2Gm5FG/WG1SqXeKyZ0k7/blY/4FdOzI12CBy1vGc4og/eus0fw==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici-types": {
      "version": "6.20.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.20.0.tgz",
      "integrity": "sha512-Ny6QZ2Nju20vw1SRHe3d9jVu6gJ+4e3+MMpqu7pqE5HT6WsTSlce++GQmK5UXS8mzV8DSYHrQH+Xrf2jVcuKNg==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/update-browserslist-db": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.3.tgz",
      "integrity": "sha512-UxhIZQ+QInVdunkDAaiazvvT/+fXL5Osr0JZlJulepYu6Jd7qJtDZjlur0emRlT71EN3ScPoE7gvsuIKKNavKw==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/vite": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/vite/-/vite-6.2.0.tgz",
      "integrity": "sha512-7dPxoo+WsT/64rDcwoOjk76XHj+TqNTIvHKcuMQ1k4/SeHDaQt5GFAeLYzrimZrMpn/O6DtdI03WUjdxuPM0oQ==",
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.25.0",
        "postcss": "^8.5.3",
        "rollup": "^4.30.1"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || ^20.0.0 || >=22.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || ^20.0.0 || >=22.0.0",
        "jiti": ">=1.21.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.16.0",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "jiti": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
      "license": "ISC"
    }
  }
}

```


## package.json

```
{
  "name": "spine-benchmark",
  "version": "1.0.0",
  "description": "A tool for benchmarking and analyzing Spine animations",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@esotericsoftware/spine-pixi-v8": "^4.2.74",
    "@paralleldrive/cuid2": "^2.2.2",
    "@vitejs/plugin-react": "^4.3.4",
    "gsap": "^3.12.7",
    "pixi.js": "^8.8.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-toastify": "^11.0.5",
    "terser": "^5.39.0"
  },
  "devDependencies": {
    "@types/node": "^22.13.5",
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "typescript": "^5.7.3",
    "vite": "^6.2.0"
  }
}

```


## scrollbars.css

```
/* Fix for info-panel-tabs inconsistent height */
.info-panel-tabs {
    display: flex;
    overflow-x: auto;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    min-height: 48px; /* Ensure minimum height even when content is empty */
    flex-shrink: 0; /* Prevent tabs from shrinking when content is large */
  }
  
  .tab-button {
    padding: 12px 16px;
    background-color: transparent;
    border: none;
    color: var(--color-light);
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s ease;
    white-space: nowrap;
    height: 100%; /* Ensure all buttons have same height */
    position: relative; /* For active indicator */
  }
  
  .tab-button:hover {
    background-color: rgba(255, 255, 255, 0.05);
  }
  
  .tab-button.active {
    background-color: rgba(255, 255, 255, 0.1);
    position: relative;
  }
  
  .tab-button.active::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 2px;
    background-color: var(--color-accent);
  }
  
  /* Improved scrollbar styles - more subtle and refined */
  .info-panel-content {
    scrollbar-width: thin; /* Firefox */
    scrollbar-color: rgba(100, 100, 100, 0.3) rgba(0, 0, 0, 0.1); /* Firefox */
    overflow-y: auto;
    flex-grow: 1;
    padding: 16px;
  }
  
  /* Chrome, Edge, and Safari scrollbars */
  .info-panel-content::-webkit-scrollbar,
  .tab-content::-webkit-scrollbar,
  .benchmark-table-container::-webkit-scrollbar {
    width: 4px; /* Even thinner for more subtlety */
    height: 4px;
  }
  
  .info-panel-content::-webkit-scrollbar-track,
  .tab-content::-webkit-scrollbar-track,
  .benchmark-table-container::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1); 
    border-radius: 2px;
  }
  
  .info-panel-content::-webkit-scrollbar-thumb,
  .tab-content::-webkit-scrollbar-thumb,
  .benchmark-table-container::-webkit-scrollbar-thumb {
    background-color: rgba(100, 100, 100, 0.3); /* More subtle gray instead of white */
    border-radius: 2px;
    transition: background-color 0.3s ease;
  }
  
  .info-panel-content::-webkit-scrollbar-thumb:hover,
  .tab-content::-webkit-scrollbar-thumb:hover,
  .benchmark-table-container::-webkit-scrollbar-thumb:hover {
    background-color: rgba(100, 100, 100, 0.5); /* Slightly darker on hover */
  }
  
  /* Make sure tab content fills available space */
  .tab-content {
    height: 100%;
    overflow-y: auto;
    padding-right: 8px; /* Add some padding to prevent content from touching scrollbar */
  }
  
  /* Ensure info panel has proper layout */
  .info-panel {
    width: 80%;
    max-width: 1000px;
    height: 80%;
    background-color: var(--color-darker);
    border-radius: var(--radius-lg);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: var(--shadow-lg);
  }
  
  /* Ensure benchmark tables have proper container */
  .benchmark-table-container {
    overflow-x: auto;
    margin: 16px 0;
    padding-bottom: 8px; /* Space for horizontal scrollbar */
  }
  
  .benchmark-table {
    width: 100%;
    border-collapse: collapse;
  }
  
  /* Fix for Mesh Analysis tab specifically */
  #meshAnalysis .tab-content,
  [data-tab="meshAnalysis"] .tab-content {
    min-height: 200px; /* Ensure minimum content height */
  }
```


## src\App.tsx

```
import React, { useState, useEffect, useRef } from 'react';
import { Application } from 'pixi.js';
import { ToastContainer } from 'react-toastify'; // Import from react-toastify
import 'react-toastify/dist/ReactToastify.css'; // Import toastify CSS
import { AnimationControls } from './components/AnimationControls';
import { InfoPanel } from './components/InfoPanel';
import { ColorPicker } from './components/ColorPicker';
import { IconButton } from './components/IconButton';
import { 
DocumentTextIcon, 
QuestionMarkCircleIcon 
} from './components/Icons';
import { useToast } from './hooks/ToastContext';
import { useSafeLocalStorage } from './hooks/useSafeLocalStorage';
import { useSpineApp } from './hooks/useSpineApp';
    

const App: React.FC = () => {
const [app, setApp] = useState<Application | null>(null);
const canvasRef = useRef<HTMLCanvasElement>(null);
const [showBenchmark, setShowBenchmark] = useState(false);
const [backgroundColor, setBackgroundColor] = useSafeLocalStorage('spine-benchmark-bg-color', '#282b30');
const [isLoading, setIsLoading] = useState(false);
const { addToast } = useToast();
const { 
  spineInstance, 
  loadSpineFiles,
  isLoading: spineLoading,
  benchmarkData
} = useSpineApp(app);

useEffect(() => {
  if (!canvasRef.current) return;
  
  let cleanupFunction: (() => void) | undefined;
  
  // Initialize PIXI Application (async)
  const initApp = async () => {
    try {
      const pixiApp = new Application();
      await pixiApp.init({
        backgroundColor: parseInt(backgroundColor.replace('#', '0x')),
        canvas: canvasRef.current!,
        resizeTo: canvasRef.current!.parentElement || undefined,
        antialias: true,
        resolution: 2,
        autoDensity: true,
      });
      
      // Store app in state for other components to use
      app?.destroy(); // Clean up old app if exists
      setApp(pixiApp);
      
      // Setup cleanup function
      cleanupFunction = () => {
        pixiApp.destroy();
      };
    } catch (error) {
      console.error("Failed to initialize Pixi application:", error);
      addToast(`Failed to initialize graphics: ${error instanceof Error ? error.message : 'Unknown error'}`, 'error');
    }
  };
  
  initApp();
  
  // Return a cleanup function
  return () => {
    if (cleanupFunction) cleanupFunction();
  };
}, []);

// Function to traverse file/directory structure - From your working example
function traverseFileTree(item: any, path: string, fileList: File[]): Promise<void> {
  path = path || "";
  
  return new Promise((resolve, reject) => {
      if (item.isFile) {
          // Get file
          item.file((file: File) => {
              console.log("File found:", path + file.name);
              // Store the path in a custom property
              Object.defineProperty(file, 'fullPath', {
                  value: path + file.name,
                  writable: false
              });
              fileList.push(file);
              resolve();
          }, reject);
      } else if (item.isDirectory) {
          // Get folder contents
          const dirReader = item.createReader();
          
          // Function to read all entries in the directory
          const readAllEntries = (entries: any[] = []): Promise<any[]> => {
              return new Promise((resolveEntries, rejectEntries) => {
                  dirReader.readEntries((results: any[]) => {
                      if (results.length) {
                          // More entries to process
                          entries = entries.concat(Array.from(results));
                          readAllEntries(entries).then(resolveEntries).catch(rejectEntries);
                      } else {
                          // No more entries, we have all of them
                          resolveEntries(entries);
                      }
                  }, rejectEntries);
              });
          };
          
          readAllEntries().then((entries) => {
              console.log(`Directory found: ${path + item.name}/ (${entries.length} entries)`);
              
              // Process all entries in the directory
              const promises = entries.map(entry => 
                  traverseFileTree(entry, path + item.name + "/", fileList)
              );
              
              Promise.all(promises)
                  .then(() => resolve())
                  .catch(reject);
          }).catch(reject);
      } else {
          resolve(); // Not a file or directory, just resolve
      }
  });
}

const handleDrop = async (e: React.DragEvent<HTMLDivElement>) => {
  e.preventDefault();
  e.stopPropagation();
  
  // Clear highlighting
  e.currentTarget.classList.remove('highlight');
  
  try {
    setIsLoading(true);
    
    // Process dropped items using the working approach from your other project
    const items = e.dataTransfer?.items;
    if (!items || items.length === 0) {
      if (!e.dataTransfer?.files || e.dataTransfer.files.length === 0) {
        addToast('No files were dropped', 'error');
        return;
      }
      // If we only have files (not items), use the simple approach
      handleSpineFiles(e.dataTransfer.files);
      return;
    }
    
    // Convert DataTransferItemList to array
    const itemsArray = Array.from(items);
    const fileList: File[] = [];
    
    // Process all dropped items (files and directories)
    const promises = itemsArray.map(item => {
      // webkitGetAsEntry is where the magic happens
      const entry = item.webkitGetAsEntry();
      if (entry) {
          return traverseFileTree(entry, "", fileList);
      } else {
          return Promise.resolve();
      }
    });
    
    // When all traversal is complete
    await Promise.all(promises);
    console.log(`Traversal complete, found ${fileList.length} files`);
    
    if (fileList.length === 0) {
      addToast('No valid files found in the dropped items', 'error');
      return;
    }
    
    console.log('Files collected:', fileList.map(f => (f as any).fullPath || f.name));
    
    // Convert to FileList-like object
    const dataTransfer = new DataTransfer();
    fileList.forEach(file => dataTransfer.items.add(file));
    const files = dataTransfer.files;
    
    // Load files into SpineBenchmark
    await handleSpineFiles(files);
    
  } catch (error) {
    console.error('Error processing dropped items:', error);
    addToast(`Error processing dropped files: ${error instanceof Error ? error.message : 'Unknown error'}`, 'error');
  } finally {
    setIsLoading(false);
  }
};

const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
  e.preventDefault();
  e.stopPropagation();
  e.currentTarget.classList.add('highlight');
};

const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => {
  e.preventDefault();
  e.stopPropagation();
  e.currentTarget.classList.remove('highlight');
};

const handleSpineFiles = async (files: FileList) => {
  try {
    // Check for JSON skeleton file
    const jsonFile = Array.from(files).find(file => file.name.endsWith('.json'));
    if (jsonFile) {
      const content = await jsonFile.text();
      if (content.includes('"spine":"4.1')) {
        addToast('Warning: This file uses Spine 4.1. The benchmark is designed for Spine 4.2. Version will be adjusted automatically.', 'warning');
        
        // Create a modified file with version replaced
        const modifiedContent = content.replace(/"spine":"4.1[^"]*"/, '"spine":"4.2.0"');
        const modifiedFile = new File([modifiedContent], jsonFile.name, { type: 'application/json' });
        
        // Replace the original file in the list
        const newFileList = Array.from(files);
        const index = newFileList.findIndex(f => f.name === jsonFile.name);
        if (index !== -1) {
          newFileList[index] = modifiedFile;
          
          // Convert back to FileList-like object
          const dataTransfer = new DataTransfer();
          newFileList.forEach(file => dataTransfer.items.add(file));
          
          await loadSpineFiles(dataTransfer.files);
          return;
        }
      }
    }
    
    await loadSpineFiles(files);
  } catch (error) {
    console.error("Error handling Spine files:", error);
    addToast(`Error loading Spine files: ${error instanceof Error ? error.message : 'Unknown error'}`, 'error');
  }
};

const openGitHubReadme = () => {
  window.open('https://github.com/schmooky/spine-benchmark/blob/main/README.md', '_blank');
};

const handleBgColorChange = (color: string) => {
  setBackgroundColor(color);
};

// Update background color when it changes
useEffect(() => {
  if (app) {
    app.renderer.background.color = parseInt(backgroundColor.replace('#', '0x'));
  }
}, [backgroundColor, app]);

return (
  <div className="app-container" style={{ backgroundColor: backgroundColor }}>
    <div 
      className="canvas-container"
      onDrop={handleDrop}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
    >
      <canvas ref={canvasRef} id="pixiCanvas" />
      
      {!spineInstance && (
        <div className="drop-area">
          <p>Drop Spine files or folders here (JSON, Atlas, and Images)</p>
        </div>
      )}
      
      {(isLoading || spineLoading) && (
        <div className="loading-indicator">
          <p>Loading...</p>
        </div>
      )}
    </div>
    
    <div className="controls-container">
      <div className="left-controls">
        <IconButton 
          icon={<DocumentTextIcon />} 
          onClick={() => setShowBenchmark(!showBenchmark)}
          active={showBenchmark}
          tooltip="Toggle Benchmark Info"
        />
        <IconButton 
          icon={<QuestionMarkCircleIcon />} 
          onClick={openGitHubReadme}
          tooltip="Open Documentation"
        />
      </div>
      
      <div className="center-controls">
        {spineInstance && <AnimationControls spineInstance={spineInstance} />}
      </div>
      
      <div className="right-controls">
        <ColorPicker 
          color={backgroundColor} 
          onChange={handleBgColorChange} 
        />
      </div>
    </div>
    
    {showBenchmark && benchmarkData && (
      <InfoPanel 
        data={benchmarkData}
        onClose={() => setShowBenchmark(false)}
      />
    )}
    
    {/* React Toastify Container with dark theme */}
    <ToastContainer
      position="top-center"
      autoClose={2000}
      hideProgressBar={false}
      newestOnTop
      closeOnClick
      rtl={false}
      pauseOnFocusLoss
      draggable
      pauseOnHover
      theme="dark"
    />
  </div>
);
};

export default App;
```


## src\CameraContainer.ts

```
import gsap from "gsap";
import { Application, Container } from "pixi.js";
import { SpineMeshOutline } from "./Outline";
import { Spine, SpineDebugRenderer } from "@esotericsoftware/spine-pixi-v8";

export class CameraContainer extends Container {
  originalWidth: any;
  originalHeight: any;
  app: Application;
  isDragging: boolean = false;
  lastPosition: { x: number; y: number } | null = null;
  initialPosition: { x: number; y: number } | null = null;
  
  meshOutline: SpineMeshOutline | null = null;
  
  
  
  private isMeshVisible: boolean = false;
  private onMeshVisibilityChange?: (isVisible: boolean) => void;
  
  
  //@ts-ignore
  contextMenu: HTMLDivElement;
  
  constructor(options: { width: number; height: number; app: Application }) {
    super();
    this.originalWidth = options.width;
    this.originalHeight = options.height;
    this.app = options.app;
    
    // Initialize context menu
    this.createContextMenu();
    
    // Setup event listeners
    this.setupEventListeners();
    
    window.addEventListener('resize', () => this.onResize());
  }
  
  
  // Add this method to set the callback
  public setMeshVisibilityCallback(callback: (isVisible: boolean) => void) {
    this.onMeshVisibilityChange = callback;
  }
  
  
  private createContextMenu() {
    // Create context menu element
    this.contextMenu = document.createElement('div');
    this.contextMenu.style.position = 'fixed';
    this.contextMenu.style.display = 'none';
    this.contextMenu.style.backgroundColor = '#282b30';
    this.contextMenu.style.border = '1px solid #ccc';
    this.contextMenu.style.padding = '5px';
    this.contextMenu.style.boxShadow = '2px 2px 5px rgba(0,0,0,0.2)';
    this.contextMenu.style.zIndex = '1000';
    
    // Create Center Viewport button
    const centerButton = document.createElement('div');
    centerButton.innerText = 'Center Viewport';
    centerButton.style.padding = '5px 10px';
    centerButton.style.cursor = 'pointer';
    centerButton.style.userSelect = 'none';
    
    centerButton.addEventListener('mouseenter', () => {
      centerButton.style.backgroundColor = '#383b40';
    });
    
    centerButton.addEventListener('mouseleave', () => {
      centerButton.style.backgroundColor = 'transparent';
    });
    
    centerButton.addEventListener('click', () => {
      this.centerViewport();
      this.hideContextMenu();
    });
    
    // Create separator
    const separator = document.createElement('div');
    separator.style.height = '1px';
    separator.style.backgroundColor = '#383b40';
    separator.style.margin = '5px 0';
    
    // Create Show Mesh toggle button
    const meshToggleContainer = document.createElement('div');
    meshToggleContainer.style.padding = '5px 10px';
    meshToggleContainer.style.cursor = 'pointer';
    meshToggleContainer.style.userSelect = 'none';
    meshToggleContainer.style.display = 'flex';
    meshToggleContainer.style.alignItems = 'center';
    meshToggleContainer.style.gap = '8px';
    
    const checkbox = document.createElement('div');
    checkbox.style.width = '14px';
    checkbox.style.height = '14px';
    checkbox.style.border = '2px solid #666';
    checkbox.style.display = 'flex';
    checkbox.style.alignItems = 'center';
    checkbox.style.justifyContent = 'center';
    
    const checkmark = document.createElement('div');
    checkmark.style.width = '8px';
    checkmark.style.height = '8px';
    checkmark.style.backgroundColor = '#666';
    checkmark.style.display = this.isMeshVisible ? 'block' : 'none';
    
    const label = document.createElement('span');
    label.innerText = 'Show Mesh';
    
    checkbox.appendChild(checkmark);
    meshToggleContainer.appendChild(checkbox);
    meshToggleContainer.appendChild(label);
    
    meshToggleContainer.addEventListener('mouseenter', () => {
      meshToggleContainer.style.backgroundColor = '#383b40';
    });
    
    meshToggleContainer.addEventListener('mouseleave', () => {
      meshToggleContainer.style.backgroundColor = 'transparent';
    });
    
    meshToggleContainer.addEventListener('click', () => {
      this.isMeshVisible = !this.isMeshVisible;
      checkmark.style.display = this.isMeshVisible ? 'block' : 'none';
      
      // Call the callback if it exists
      if (this.onMeshVisibilityChange) {
        this.onMeshVisibilityChange(this.isMeshVisible);
      }
    });
    
    // Add all elements to context menu
    this.contextMenu.appendChild(centerButton);
    this.contextMenu.appendChild(separator);
    this.contextMenu.appendChild(meshToggleContainer);
    
    document.body.appendChild(this.contextMenu);
  }
  
  private setupEventListeners() {
    const view = document.getElementById('leftPanel')!;
    
    // Mouse down event for panning
    view.addEventListener('mousedown', (e: MouseEvent) => {
      if (e.button === 0) { // Left mouse button
        this.isDragging = true;
        this.lastPosition = { x: e.clientX, y: e.clientY };
        view.style.cursor = 'grabbing';
      }
    });
    
    // Mouse move event for panning
    window.addEventListener('mousemove', (e: MouseEvent) => {
      if (this.isDragging && this.lastPosition) {
        const dx = e.clientX - this.lastPosition.x;
        const dy = e.clientY - this.lastPosition.y;
        
        this.x += dx;
        this.y += dy;
        
        this.lastPosition = { x: e.clientX, y: e.clientY };
      }
    });
    
    // Mouse up event to stop panning
    window.addEventListener('mouseup', (e: MouseEvent) => {
      if (e.button === 0) { // Left mouse button
        this.isDragging = false;
        this.lastPosition = null;
        view.style.cursor = 'default';
      }
    });
    
    // Context menu event
    view.addEventListener('contextmenu', (e: MouseEvent) => {
      e.preventDefault();
      this.showContextMenu(e.clientX, e.clientY);
    });
    
    // Hide context menu when clicking outside
    window.addEventListener('click', (e: MouseEvent) => {
      if (!this.contextMenu.contains(e.target as Node)) {
        this.hideContextMenu();
      }
    });
  }
  
  private showContextMenu(x: number, y: number) {
    this.contextMenu.style.display = 'block';
    this.contextMenu.style.left = `${x}px`;
    this.contextMenu.style.top = `${y}px`;
  }
  
  private hideContextMenu() {
    this.contextMenu.style.display = 'none';
  }
  
  private centerViewport() {
    const w = this.app.renderer.width;
    const h = this.app.renderer.height;
    
    gsap.to(this, {
      x: w / 2,
      y: h / 2,
      duration: 0.5,
      ease: "power2.out",
    });
  }
  
  onResize() {
    const w = this.app.renderer.width;
    const h = this.app.renderer.height;
    
    this.x = w / 2;
    this.y = h / 2;
  }
  
  lookAtChild(spine: Spine) {
    const debugRenderer = new SpineDebugRenderer();
    debugRenderer.registerSpine(spine);

    this.app.ticker.add(() => {
      if(this.isMeshVisible)      debugRenderer.renderDebug(spine);
      else {
        const debugDisplayObjects = debugRenderer['registeredSpines'].get(spine);
        debugDisplayObjects.skeletonXY.clear();
        debugDisplayObjects.regionAttachmentsShape.clear();
        debugDisplayObjects.meshTrianglesLine.clear();
        debugDisplayObjects.meshHullLine.clear();
        debugDisplayObjects.clippingPolygon.clear();
        debugDisplayObjects.boundingBoxesRect.clear();
        debugDisplayObjects.boundingBoxesCircle.clear();
        debugDisplayObjects.boundingBoxesPolygon.clear();
        debugDisplayObjects.pathsCurve.clear();
        debugDisplayObjects.pathsLine.clear();
        for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {
          debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, textureSource: true });
      }
      }
    });
    console.log(`Looking at: `, spine)

    const padding = 20;
    // Get the bounds of the object in global space
    let bounds: { width: number; height: number; x: number; y: number } =
    spine.getBounds();
    if (bounds.width == 0 || bounds.height == 0) {
      bounds.width = spine.skeleton.data.width / 2;
      bounds.height = spine.skeleton.data.height / 2;
    }
    
    // Calculate the scale needed to fit the object within the screen
    const scaleX = (this.app.screen.width - padding * 2) / bounds.width;
    const scaleY = (this.app.screen.height - padding * 2) / bounds.height;
    let scale = Math.min(scaleX, scaleY);
    spine.scale = scale;
    
    const minScale = 0.2;
    const maxScale = 10;
    const scaleStep = 0.1;
    
    // Calculate the position to center the object
    const x = this.app.screen.width / 2;
    const y = this.app.screen.height / 2;
    
    // Animate the camera to look at the object
    gsap.to(this, {
      x: x,
      y: y,
      duration: 1,
      ease: "power2.out",
    });
    
    scale = +(Math.ceil(scale*20)/20).toFixed(2);
    this.scale.set(scale);
    this.setCanvasScaleDebugInfo(scale);
    document
    .getElementById("leftPanel")!
    .addEventListener("wheel", (event) => {
      event.preventDefault();
      
      // Determine scroll direction
      const scrollDirection = Math.sign(event.deltaY);
      
      // Update scale based on scroll direction
      scale -= scrollDirection * scaleStep;
      
      scale = +(Math.ceil(scale*20)/20).toFixed(2);
      
      // Clamp scale between minScale and maxScale
      scale = Math.max(minScale, Math.min(maxScale, scale));
      
      // Apply the new scale to the container
      this.scale.set(scale);
      
      this.setCanvasScaleDebugInfo(scale);
    });
  }
  
  setCanvasScaleDebugInfo(scale: number) {
    const debug = document.getElementById("canvasScale");
    if (!debug) return;
    debug.innerText = `Scale: x${scale.toFixed(2)}`;
  }
  
  public destroy() {
    // Remove event listeners
    window.removeEventListener('resize', this.onResize);
    
    // Remove context menu from DOM
    if (this.contextMenu && this.contextMenu.parentNode) {
      this.contextMenu.parentNode.removeChild(this.contextMenu);
    }
    
    // Call parent destroy method
    super.destroy();
  }
  
  // Add getter for mesh visibility state
  public getMeshVisibility(): boolean {
    return this.isMeshVisible;
  }
  
  // Add setter for mesh visibility state
  public setMeshVisibility(isVisible: boolean) {
    this.isMeshVisible = isVisible;
    // Update checkbox visual if context menu exists
    const checkmark = this.contextMenu.querySelector('div > div > div') as HTMLDivElement;
    if (checkmark) {
      checkmark.style.display = isVisible ? 'block' : 'none';
    }
    // Call the callback if it exists
    if (this.onMeshVisibilityChange) {
      this.onMeshVisibilityChange(isVisible);
    }
  }
  
}

```


## src\Outline.ts

```
import { Application, Container, Graphics } from "pixi.js";
import {NumberArrayLike, Spine, VertexAttachment} from '@esotericsoftware/spine-pixi-v8'


const areaThreshold = 72;

const outlineColor = 0x2a2a2a;

export class SpineMeshOutline {
    app: Application;
    spine: Spine;
    graphics: Graphics;
    scale: number = 1;

    constructor(app: Application, spineInstance: Spine) {
        this.spine = spineInstance;
        this.graphics = new Graphics();
        this.spine.addChild(this.graphics as unknown as Container);
        
        // Bind the update method to maintain correct context
        this.update = this.update.bind(this);
        this.app = app;
        // Start updating
        app.ticker.add(this.update);
    }

        // Add this helper function to calculate triangle area
        private calculateTriangleArea(v1: [number, number], v2: [number, number], v3: [number, number]): number {
            // Using the formula: Area = |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)| / 2
            const area = Math.abs(
                v1[0] * (v2[1] - v3[1]) +
                v2[0] * (v3[1] - v1[1]) +
                v3[0] * (v1[1] - v2[1])
            ) / 2;
            return area;
        }

    drawMeshOutline(vertices: NumberArrayLike, triangles: Array<number>, color = outlineColor, thickness = 2, alpha = 0.8) {
        const graphics = this.graphics;
        if(!triangles) return;
        // Clear previous drawings
        
        // Set line style
        graphics.lineStyle(thickness*this.scale, color, alpha);

        // Create a Set to store unique edges
        const edges = new Set<string>();

        

        // Process triangles to find edges
        for (let i = 0; i < triangles.length; i += 3) {
            const vertices1 = [
                vertices[triangles[i] * 2],
                vertices[triangles[i] * 2 + 1]
            ];
            const vertices2 = [
                vertices[triangles[i + 1] * 2],
                vertices[triangles[i + 1] * 2 + 1]
            ];
            const vertices3 = [
                vertices[triangles[i + 2] * 2],
                vertices[triangles[i + 2] * 2 + 1]
            ];

                        // Calculate triangle area
                        const area = this.calculateTriangleArea(vertices1  as [number,number], vertices2  as [number,number], vertices3  as [number,number]);
                        // If area is less than threshold, fill the triangle with semi-transparent red
                        if (area < areaThreshold) {
                            graphics.beginFill(outlineColor, 0.2); // Red color with 20% opacity
                            graphics.moveTo(vertices1[0], vertices1[1]);
                            graphics.lineTo(vertices2[0], vertices2[1]);
                            graphics.lineTo(vertices3[0], vertices3[1]);
                            graphics.lineTo(vertices1[0], vertices1[1]);
                            graphics.endFill();
                        }

            // Add edges (sorted to avoid duplicates)
            this.addEdge(edges, vertices1 as [number,number], vertices2 as [number,number]);
            this.addEdge(edges, vertices2 as [number,number], vertices3 as [number,number]);
            this.addEdge(edges, vertices3 as [number,number], vertices1 as [number,number]);
        }

        // Draw all unique edges
        for (const edge of edges) {
            const [x1, y1, x2, y2] = edge.split(',').map(Number);
            graphics.moveTo(x1, y1);
            graphics.lineTo(x2, y2);
        }
    }

    addEdge(edges:Set<string>, point1: [number,number], point2:  [number,number]) {
        // Sort points to ensure consistent edge representation
        const [x1, y1] = point1;
        const [x2, y2] = point2;
        
        if (x1 === x2 && y1 === y2) return; // Skip zero-length edges
        
        const edgeKey = x1 < x2 || (x1 === x2 && y1 < y2)
            ? `${x1},${y1},${x2},${y2}`
            : `${x2},${y2},${x1},${y1}`;
            
        edges.add(edgeKey);
    }

    update() {
    // Clear previous drawings
    this.graphics?.clear();

    // Iterate through all slots
    for (const slot of this.spine.skeleton.slots) {
        const attachment = slot.attachment;
        
        // Check if attachment is a mesh
        if (attachment && (attachment as VertexAttachment).vertices) {
            // Skip if slot is invisible or attachment has no name
            if(slot.color.a === 0 || attachment.name == null) continue;

            // Get mesh vertices
            const vertices = new Float32Array((attachment as VertexAttachment).vertices.length);
            (attachment as VertexAttachment).computeWorldVertices(
                slot,
                0,
                (attachment as VertexAttachment).vertices.length,
                vertices,
                0,
                2
            );

            // Draw outline for this mesh
            this.drawMeshOutline(
                vertices,
                (attachment as any).triangles, // Cast to any to access triangles
                outlineColor, // Red color
                0.75, // Line thickness
                0.75 // Alpha
            );
        }
    }
}

    destroy() {
        this.app.ticker.remove(this.update);
        this.graphics.destroy();
    }
}
```


## src\PerformanceMonitor.ts

```
export class PerformanceMonitor {
    private lastTime: number;
    private frames: number;

    constructor() {
        this.lastTime = performance.now();
        this.frames = 0;
    }

    public getPerformanceInfo() {
        const now = performance.now();
        this.frames++;

        if (now > this.lastTime + 1000) {
            const fps = (this.frames * 1000) / (now - this.lastTime);
            this.lastTime = now;
            this.frames = 0;

            return { fps };
        }

        return { fps: 0 };
    }
}
```


## src\SpineAnalyzer.ts

```
import { analyzeClipping } from "./analyze/clipping";
import { analyzeSpineBlendModes } from "./analyze/blendModes";
import { Spine } from "@esotericsoftware/spine-pixi-v8";
import { analyzeMeshes } from "./analyze/mesh";
import { analyzePhysics } from "./analyze/physics";
import { createSkeletonTree } from "./analyze/skeleton";

export class SpineAnalyzer {
  static analyze(spineInstance: Spine) {
      analyzeClipping(spineInstance);
      analyzeSpineBlendModes(spineInstance);
      analyzeMeshes(spineInstance);
      analyzePhysics(spineInstance);
      createSkeletonTree(spineInstance);
  }
}

```


## src\SpineBenchmark.ts

```
import { Application, Assets } from "pixi.js";
import { SpineAnalyzer } from "./SpineAnalyzer";
import { CameraContainer } from "./CameraContainer";

import {
  AtlasAttachmentLoader,
  SkeletonJson,
  Spine,
  SpineTexture,
  TextureAtlas,
} from "@esotericsoftware/spine-pixi-v8";
import { extensions, ExtensionType, Texture } from 'pixi.js';

const blobParser = {
    extension: ExtensionType.LoadParser,
    test: (url: string) => url.startsWith('blob:'),
    async load(url: string) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(Texture.from(img));
            img.onerror = reject;
            img.src = url;
        });
    }
};

extensions.add(blobParser);

export class SpineBenchmark {
  private app: Application;
  private spineInstance: Spine | null = null; // Store the single Spine instance
  private isBinary = false;

  constructor(app: Application) {
    this.app = app;
  }

  public async loadSpineFiles(files: FileList) {
    const acceptedFiles = Array.from(files);
    const imageFiles = acceptedFiles.filter(file => file.type.match(/image/));
    
    try {
        // Load textures
        const assetBundle: Record<string, any> = {};
        
        await Promise.all(imageFiles.map(async (file) => {
            const base64 = await new Promise<string>((resolve) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result as string);
                reader.readAsDataURL(file);
            });
            
            assetBundle[file.name] = {
                src: base64,
                data: { type: file.type }
            };
        }));
        
        // Add and load bundle
        Assets.addBundle('spineAssets', assetBundle);
        const textures = await Assets.loadBundle('spineAssets');

        // Load skeleton and atlas files
        const skelFile = acceptedFiles.find(file => /^.+\.skel$/.test(file.name));
        const jsonFile = acceptedFiles.find(file => file.type === "application/json");
        const atlasFile = acceptedFiles.find(file => file.name.endsWith('.atlas'));
        
        let skeletonData;
        if (skelFile) {
            this.isBinary = true;
            skeletonData = await this.readFileAsArrayBuffer(skelFile);
        } else if (jsonFile) {
            const jsonText = await this.readFileAsText(jsonFile);
            skeletonData = JSON.parse(jsonText);
        } else {
            throw new Error('No skeleton file (.skel or .json) found');
        }
        
        if (!atlasFile) {
            throw new Error('No atlas file found');
        }
        const atlasText = await this.readFileAsText(atlasFile);
        
        // Create spine asset
        await this.createSpineAsset(skeletonData, atlasText, textures);
        
    } catch (error) {
        console.error('Error loading Spine files:', error);
    }
}

private readFileAsText(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as string);
      reader.onerror = () => reject(reader.error);
      reader.readAsText(file);
  });
}

private readFileAsArrayBuffer(file: File): Promise<ArrayBuffer> {
  return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as ArrayBuffer);
      reader.onerror = () => reject(reader.error);
      reader.readAsArrayBuffer(file);
  });
}

private async createSpineAsset(
  data: any, 
  atlasText: string, 
  textures: Record<string, Texture>
): Promise<void> {
  console.log("Creating Spine Asset");
  // Create atlas
  const spineAtlas = new TextureAtlas(atlasText);
  
  // Process each page in the atlas
  for (const page of spineAtlas.pages) {
      const pageName = page.name;
      const texture = textures[pageName];

      if (!texture) {
          console.error(`Missing texture for page: ${pageName}`);
          throw new Error(`Missing texture for page: ${pageName}`);
      }

      // Create SpineTexture from the PIXI Texture
      const spineTexture = SpineTexture.from(texture.source);
      
      // Set the texture for the page
      page.setTexture(spineTexture);

      // Handle PMA (Premultiplied Alpha) if needed
      // if (page.pma) {
      //     texture.alphaMode = ALPHA_MODES.PREMULTIPLIED_ALPHA;
      // } else {
      //     texture.alphaMode = ALPHA_MODES.PREMULTIPLY_ON_UPLOAD;
      // }
      
  }

  // Create attachment loader
  const atlasLoader = new AtlasAttachmentLoader(spineAtlas);

  // Create skeleton data
  const skeletonJson = new SkeletonJson(atlasLoader);
  const skeletonData = skeletonJson.readSkeletonData(data);

  // Create spine instance
  const spine = new Spine(skeletonData);
  this.app.stage.addChild(spine
  );

  const camera = this.app.stage.children[0] as CameraContainer;

  // Remove previous Spine instance if exists
  if (this.spineInstance) {
    camera.removeChild(this.spineInstance);
  }

  camera.addChild(spine);
  camera.lookAtChild(spine);

  SpineAnalyzer.analyze(spine)

  this.createAnimationButtons(spine);
  this.createSkinButtons(spine);
}

  // UI functions:
  private createAnimationButtons(spineInstance: Spine) {
    const animations = spineInstance.skeleton.data.animations;
    const container = document.getElementById("sidebarAnimations")!;

    container.classList.remove("hidden");

    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }

    animations.forEach((animation) => {
      const button = document.createElement("button");
      button.textContent = animation.name;

      button.addEventListener("click", () => {
        console.log(`Set ${animation.name}`)
        spineInstance.state.setAnimation(0, animation.name, false);
      });

      container.appendChild(button);
    });
  }

  private createSkinButtons(spineInstance: Spine) {
    const skins = spineInstance.skeleton.data.skins;
    const container = document.getElementById("sidebarSkins")!;

    container.classList.remove("hidden");

    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }

    skins.forEach((skin) => {
      const button = document.createElement("button");
      button.textContent = skin.name;

      button.addEventListener("click", () => {
        spineInstance.skeleton.setSkinByName(skin.name);
        spineInstance.skeleton.setSlotsToSetupPose();
      });

      container.appendChild(button);
    });
  }

  // Usage example:
  // Assuming you have a Spine instance called 'spineInstance'
  // const spineInstance = new PIXI.spine.Spine(spineData);
  // const analysis = analyzeSpineSkeleton(spineInstance);

  playSpineAnimationsInSequence(spineInstance: Spine) {
    const animations = spineInstance.skeleton.data.animations;
    let currentIndex = 0;
    spineInstance.state.addListener({
      complete: function () {
        currentIndex++;
        setTimeout(playNextAnimation, 250);
      },
    });
    function playNextAnimation() {
      if (currentIndex < animations.length) {
        const animation = animations[currentIndex];

        document.getElementById(
          "currentAnimation"
        )!.innerHTML = `Animation: ${animation.name}`;
        spineInstance.state.setAnimation(0, animation.name, false);
      } else {
        currentIndex = 0;
        setTimeout(playNextAnimation, 250);
      }
    }

    playNextAnimation();
  }
}

```


## src\analyze\blendModes.ts

```
import { html } from "../text/blend.md";
import { BlendMode, Spine } from "@esotericsoftware/spine-pixi-v8";


document.querySelector("#blendModesContainerText")!.innerHTML = html; // <h1>Markdown File</h1>

export function analyzeSpineBlendModes(spine: Spine): void {
  console.log('Analyze: Blend Modes')
  const skeletonData = spine.skeleton.data;
  const animations = skeletonData.animations;
  const slots = skeletonData.slots;
  
  // Helper function to check if a blend mode is non-normal
  const isNonNormalBlendMode = (blendMode: BlendMode): boolean => {
    return blendMode !== BlendMode.Normal;
  };
  
  const nonNormalBlendModeSlots = checkSkeletonForNonNormalBlendModes(spine);
  appendBlendModeWarning(nonNormalBlendModeSlots);
  
  // Analyze each animation
  animations.forEach(animation => {
    let maxVisibleNonNormalBlendModes = 0;
    const nonNormalBlendModeSlots: Set<string> = new Set();
    
    // Check each keyframe of the animation
    for (let time = 0; time <= animation.duration; time += 1/60) { // Assuming 30 FPS
      let visibleNonNormalBlendModes = 0;
      
      slots.forEach(slot => {
        if(!slot.attachmentName) return
        const attachment = spine.skeleton.getAttachmentByName(slot.name,slot.attachmentName);
        if (attachment && slot.visible && slot.color.a > 0) {
          const blendMode = slot.blendMode;
          if (isNonNormalBlendMode(blendMode)) {
            visibleNonNormalBlendModes++;
            nonNormalBlendModeSlots.add(slot.name);
          }
        }
      });
      
      maxVisibleNonNormalBlendModes = Math.max(maxVisibleNonNormalBlendModes, visibleNonNormalBlendModes);
    }
    
    // If more than two non-normal blend modes are visible simultaneously
    if (maxVisibleNonNormalBlendModes > 2) {
      appendBlendModeAnimationWarning(animation.name, maxVisibleNonNormalBlendModes, Array.from(nonNormalBlendModeSlots));
    }
  });
}

function appendBlendModeAnimationWarning(
  animationName: string,
  maxVisibleNonNormalBlendModes: number,
  affectedSlots: string[]
): void {
  const container = document.getElementById("blendModesContainer");
  if (!container) return;
  
  const infoBlock = document.createElement("div");
  infoBlock.className = "warning";
  infoBlock.innerHTML = `
    <h3>Blend Mode Problems in ${animationName}</h3>
  `;
  
  container.appendChild(infoBlock);
}
function checkSkeletonForNonNormalBlendModes(spine: Spine): Map<string,BlendMode> {
  const nonNormalBlendModeSlots = new Map<string,BlendMode>();
  const skeletonData = spine.skeleton.data;
  
  for (let i = 0; i < skeletonData.slots.length; i++) {
    const slotData = skeletonData.slots[i];
    const blendMode = slotData.blendMode;
    if (blendMode !== BlendMode.Normal) {
      nonNormalBlendModeSlots.set(slotData.name, blendMode);
    }
  }
  
  return nonNormalBlendModeSlots;
}

function appendBlendModeWarning(
  blendModeMap: Map<string, BlendMode>
): void {
  const container = document.getElementById("blendModesContainer");
  if (!container) return;
  
  // Count occurrences of each blend mode
  const blendModeCount = new Map<BlendMode, number>();
  let nonNormalCount = 0;
  
  blendModeMap.forEach((blendMode, slotName) => {
    blendModeCount.set(blendMode, (blendModeCount.get(blendMode) || 0) + 1);
    if (blendMode !== BlendMode.Normal) {
      nonNormalCount++;
    }
  });
  
  const infoBlock = document.createElement("div");
  infoBlock.className = "";
  infoBlock.innerHTML = `
    <p><strong>Total non-normal blend modes:</strong> ${nonNormalCount}</p>
          ${Array.from(blendModeCount).map(([mode, count]) => `
        <p>${BlendMode[mode]} blend mode: ${count}</p>
      `).join('')}
  `;
  
  document.getElementById('benchmarkSummary')!.appendChild(infoBlock);
}
```


## src\analyze\clipping.ts

```
import { ClippingAttachment, Spine } from '@esotericsoftware/spine-pixi-v8';
import { html } from "../text/clipping.md";

document.querySelector("#clippingContainerText")!.innerHTML = html; // <h1>Markdown File</h1>

export function analyzeClipping(spine: Spine): void {
  console.log('Analyze: Clipping')
  console.log(spine.skeleton.slots)
  const masks: [string,number][] = []
  spine.skeleton.slots.forEach((slot) => {
    if (slot.attachment && slot.attachment instanceof ClippingAttachment) {
      const clipping = slot.attachment as ClippingAttachment;
      const verticesCount = clipping.worldVerticesLength / 2; // Divide by 2 because each vertex has x and y
      appendMaskInfo(slot.data.name, verticesCount);
      masks.push([slot.data.name, verticesCount])
    }
  });
  appendMaskSummary(masks)
}

function appendMaskInfo(slotName: string, verticesCount: number): void {
  const container = document.getElementById("clippingContainer");
  if (!container) return;
  
  const infoBlock = document.createElement("div");
  infoBlock.className = verticesCount > 4 ? "warning" : "info";
  infoBlock.innerHTML = `
    <h3>Mask Detected</h3>
    <p><strong>Slot name:</strong> ${slotName}</p>
    <p><strong>Vertices count:</strong> ${verticesCount}</p>
  `;
  
  container.appendChild(infoBlock);
}


function appendMaskSummary(masks: [string,number][]): void {
  const container = document.getElementById("clippingContainer");
  if (!container) return;
  
  const infoBlock = document.createElement("div");
  infoBlock.innerHTML = `
    <h3><strong>Mask Count: ${masks.length}</strong></h3>
    <p>Mask Vertice Counts: ${masks.map((_)=>_[1]).join(', ')}</p>
  `;

  document.getElementById('benchmarkSummary')!.appendChild(infoBlock);
}
```


## src\analyze\mesh.ts

```
import { DeformTimeline, MeshAttachment, Spine } from "@esotericsoftware/spine-pixi-v8";
import { attributes, html } from "../text/mesh.md";

document.querySelector("#meshTableContainerText")!.innerHTML = html; // <h1>Markdown File</h1>

function mergeMaps(
  map1: Map<string, any>,
  map2: Map<string, any>,
  map3: Map<string, any>,
  map4: Map<string, boolean>
): Map<string, Record<string, any>> {
  const mergedMap = new Map();

  // Merge keys from both maps
  const allKeys = new Set([...map1.keys(), ...map2.keys(), ...map3.keys()]);

  allKeys.forEach((key) => {
    mergedMap.set(key, {
      vertices: map1.get(key) ?? "",
      isChanged: map2.get(key) ?? "",
      isBoneWeighted: map3.get(key) ?? 0,
      isUsedInMeshSequence: map4.get(key) ?? false,
    });
  });

  return mergedMap;
}

function createTable(
  mergedMap: Map<string, Record<string, any>>,
  columns: string[]
) {
  const table = document.createElement("table");
  table.className = "merged-table";

  // Create table header
  const thead = table.createTHead();
  const headerRow = thead.insertRow();
  columns.forEach((text) => {
    const th = document.createElement("th");
    th.textContent = text;
    headerRow.appendChild(th);
  });

  // Create table body
  const tbody = table.createTBody();
  mergedMap.forEach((value, key) => {
    const row = tbody.insertRow();
    const cellKey = row.insertCell();
    const cellValue1 = row.insertCell();
    const cellValue2 = row.insertCell();
    const cellValue3 = row.insertCell();
    const cellValue4 = row.insertCell();

    cellKey.textContent = key;
    cellValue1.textContent = value.vertices;
    cellValue2.textContent = value.isChanged;
    cellValue3.textContent = value.isBoneWeighted;
    cellValue4.textContent = value.isUsedInMeshSequence;

    // if ((!value.isChanged && !value.isBoneWeighted) || value.vertices > 64) {
    //   row.classList.add("error");
    // } else if (value.vertices > 8) {
    //   row.classList.add("warn");
    // }

    function interpolateColor(color1: [number,number,number], color2: [number,number,number], factor: number) {
      const result = color1.slice();
      for (let i = 0; i < 3; i++) {
        result[i] = Math.round(result[i] + factor * (color2[i] - color1[i]));
      }
      return result;
    }

    // Set color based on vertex count
    function setRowColor(row: HTMLTableRowElement, vertexCount: number) {
      const minVertices = 1;
      const maxVertices = 2000;
      const colorStart: [number,number,number] = [255, 243, 224]; // #fff3e0
      const colorMiddle: [number,number,number] = [255, 204, 128]; // #ffcc80
      const colorEnd: [number,number,number] = [239, 154, 154]; // #ef9a9a

      // Calculate logarithmic factor
      const logFactor = Math.log(vertexCount) / Math.log(maxVertices);

      let color;
      if (logFactor <= 0.5) {
        color = interpolateColor(colorStart, colorMiddle, logFactor * 2);
      } else {
        color = interpolateColor(colorMiddle, colorEnd, (logFactor - 0.5) * 2);
      }

      // Make color darker as it approaches maxVertices
      const darkenFactor = Math.min(logFactor * 0.08, 0.08);
      color = color.map((c) => Math.round(c * (1 - darkenFactor)));

      row.style.backgroundColor = rgbToRgba(`rgb(${color})`);
    }

    // Apply color to the row
    setRowColor(row, value.vertices);
  });

  return table;
}

export function analyzeMeshes(spineInstance: Spine) {
  if (!spineInstance || !spineInstance.skeleton) {
    console.error("Invalid Spine instance provided");
    return;
  }
  console.group("analyzeMeshes");
  const skeleton = spineInstance.skeleton;
  const animations = spineInstance.skeleton.data.animations;

  let totalMeshCount = 0;
  let changedMeshCount = 0;
  const meshesWithChangesInTimelines = new Map();
  const meshWorldVerticesLengths = new Map<string, number>();
  const meshesWithBoneWeights = new Map<string, number>();
  const meshesWithParents = new Map<string, boolean>();
  // Count total meshes
  skeleton.slots.forEach((slot) => {
    const attachment = slot.getAttachment();
    if (
      attachment &&
      attachment instanceof MeshAttachment
    ) {
      totalMeshCount++;
      if (attachment.bones?.length)
        meshesWithBoneWeights.set(slot.data.name, attachment.bones.length);
      meshWorldVerticesLengths.set(
        slot.data.name,
        attachment.worldVerticesLength
      );
      meshesWithChangesInTimelines.set(slot.data.name, false);
      meshesWithParents.set(slot.data.name, attachment.getParentMesh() != null);
    }
  });
  console.table(
    Array.from(meshWorldVerticesLengths).reduce(
      (acc: Record<string, number>, [slotName, value]) => {
        acc[slotName] = value;
        return acc;
      },
      {}
    )
  );
  // Analyze animations for mesh changes
  animations.forEach((animation) => {
    const timelines = animation.timelines;

    timelines.forEach((timeline) => {
      if (timeline instanceof DeformTimeline) {
        const slotIndex = timeline.slotIndex;
        const slot = skeleton.slots[slotIndex];
        const attachment = slot.getAttachment();

        if (
          attachment &&
          attachment instanceof MeshAttachment
        ) {
          meshesWithChangesInTimelines.set(slot.data.name, true);
        }
      }
    });
  });

  const allKeys = new Set([
    ...meshWorldVerticesLengths.keys(),
    ...meshesWithChangesInTimelines.keys(),
    ...meshesWithBoneWeights.keys(),
    ...meshesWithParents.keys(),
  ]);

  const combinedArray = Array.from(allKeys, (key) => ({
    Key: key,
    "Mesh Vertices": meshWorldVerticesLengths.get(key) || "",
    "Is Changed in Animation": meshesWithChangesInTimelines.get(key),
    "Is Affected By Bones": meshesWithBoneWeights.get(key) ?? 0,
    "Is Used in Mesh Sequence": meshesWithParents.get(key) ?? false,
  }));

  console.table(combinedArray);

  const mergedMap = mergeMaps(
    meshWorldVerticesLengths,
    meshesWithChangesInTimelines,
    meshesWithBoneWeights,
    meshesWithParents
  );
  const table = createTable(mergedMap, [
    "Слот",
    "Вершины",
    "Деформируется в таймлайнах",
    "Связан с костями",
    "Имеет родительский меш",
  ]);

  document.getElementById("meshTableContainer")!.appendChild(table);

  console.groupEnd();
}

function appendMeshMisuseInfo(
  slotName: string,
  isUsedInMeshSequence: boolean
): void {
  const container = document.getElementById("meshTableContainer");
  if (!container) return;

  const infoBlock = document.createElement("div");
  infoBlock.className = "warning";
  infoBlock.innerHTML = `
        <h3>Potential Mesh Misuse Detected</h3>
        <p><strong>Slot name:</strong> ${slotName}</p>
        <p><strong>Deformed in timeline:</strong> false</p>
        <p><strong>Affected by bones</strong> false</p>
        <p><strong>Used in sequence:</strong> ${isUsedInMeshSequence}</p>
  
  `;

  container.appendChild(infoBlock);
}


function rgbToRgba(rgbString: string, alpha = 0.8) {
  // Regular expression to match the RGB values
  const rgbRegex = /rgb\((\d+),\s*(\d+),\s*(\d+)\)/;
  
  // Extract RGB values from the input string
  const match = rgbString.match(rgbRegex);
  
  if (!match) {
    throw new Error("Invalid RGB string format. Expected 'rgb(r, g, b)'");
  }
  
  // Parse the RGB values
  const [, r, g, b] = match.map(Number);
  
  // Validate RGB values
  if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
    throw new Error("RGB values must be between 0 and 255");
  }
  
  // Validate alpha value
  if (alpha < 0 || alpha > 1) {
    throw new Error("Alpha value must be between 0 and 1");
  }
  
  // Construct the RGBA string
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}
```


## src\analyze\physics.ts

```
import { Spine } from "@esotericsoftware/spine-pixi-v8"

export function analyzePhysics(spine: Spine): void {
  console.log('Analyze: Physics')
  console.log(spine.skeleton.physicsConstraints)
  
}
```


## src\analyze\skeleton.ts

```
import { Spine, Bone, Slot } from "@esotericsoftware/spine-pixi-v8";

export function createSkeletonTree(spineInstance: Spine) {
  if (!spineInstance || !spineInstance.skeleton) {
    console.error("Invalid Spine instance provided");
    return;
  }

  console.group("createSkeletonTree");
  const skeleton = spineInstance.skeleton;
  
  // Create the tree container
  const treeContainer = document.createElement("div");
  treeContainer.className = "skeleton-tree-container";
  
  // Create tree root
  const treeUl = document.createElement("ul");
  treeUl.className = "skeleton-tree";
  
  // Add skeleton root node
  const rootLi = document.createElement("li");
  rootLi.className = "tree-node skeleton-root";
  
  const rootSpan = document.createElement("span");
  rootSpan.textContent = `Skeleton (${skeleton.data.name || "unnamed"})`;
  rootSpan.className = "node-label";
  rootLi.appendChild(rootSpan);
  
  // Build bones hierarchy
  const bonesUl = document.createElement("ul");
  const rootBones = skeleton.bones.filter(bone => !bone.parent);
  
  rootBones.forEach(rootBone => {
    bonesUl.appendChild(buildBoneNode(rootBone));
  });
  
  rootLi.appendChild(bonesUl);
  treeUl.appendChild(rootLi);
  treeContainer.appendChild(treeUl);
  
  // Add slots information
  const slotsUl = document.createElement("ul");
  slotsUl.className = "slots-list";
  
  skeleton.slots.forEach(slot => {
    const slotLi = buildSlotNode(slot);
    slotsUl.appendChild(slotLi);
  });
  
  rootLi.appendChild(slotsUl);
  
  // Append to document
  document.getElementById("skeletonTreeContainer")?.appendChild(treeContainer) || 
    document.body.appendChild(treeContainer);
  
  // Add basic styling
  addTreeStyles();
  
  console.groupEnd();
}

function buildBoneNode(bone: Bone): HTMLLIElement {
  const li = document.createElement("li");
  li.className = "tree-node bone-node";
  
  const span = document.createElement("span");
  span.className = "node-label";
  span.textContent = `Bone: ${bone.data.name} (x: ${bone.x.toFixed(2)}, y: ${bone.y.toFixed(2)})`;
  li.appendChild(span);
  
  // Add children bones
  const children = bone.children;
  if (children.length > 0) {
    const ul = document.createElement("ul");
    children.forEach(childBone => {
      ul.appendChild(buildBoneNode(childBone));
    });
    li.appendChild(ul);
  }
  
  // Make node collapsible
  span.addEventListener("click", (e) => {
    e.stopPropagation();
    li.classList.toggle("collapsed");
  });
  
  return li;
}

function buildSlotNode(slot: Slot): HTMLLIElement {
  const li = document.createElement("li");
  li.className = "tree-node slot-node";
  
  const span = document.createElement("span");
  span.className = "node-label";
  span.textContent = `Slot: ${slot.data.name} (Bone: ${slot.bone.data.name})`;
  
  const attachment = slot.getAttachment();
  if (attachment) {
    const attachmentSpan = document.createElement("span");
    attachmentSpan.className = "attachment-label";
    attachmentSpan.textContent = `Attachment: ${attachment.name}`;
    li.appendChild(attachmentSpan);
  }
  
  li.appendChild(span);
  
  return li;
}

function addTreeStyles() {
  const style = document.createElement("style");
  style.textContent = `
    .skeleton-tree-container {
      margin: 20px;
      font-family: Arial, sans-serif;
    }
    .skeleton-tree {
      list-style: none;
      padding-left: 0;
    }
    .tree-node {
      margin: 5px 0;
      position: relative;
    }
    .node-label {
      cursor: pointer;
      padding: 2px 5px;
      border-radius: 3px;
    }
    .node-label:hover {
      background-color: #f0f0f0;
    }
    .bone-node ul {
      padding-left: 20px;
      margin: 5px 0;
    }
    .slots-list {
      padding-left: 20px;
      margin: 5px 0;
      border-left: 1px dashed #ccc;
    }
    .collapsed > ul {
      display: none;
    }
    .attachment-label {
      display: block;
      padding-left: 25px;
      font-size: 0.9em;
      color: #666;
    }
    .skeleton-root > .node-label {
      font-weight: bold;
      background-color: #e0e0e0;
    }
  `;
  document.head.appendChild(style);
}

// Usage example:
// const spine = new Spine(spineData);
// createSkeletonTree(spine);
```


## src\components\AnimationControls.tsx

```
import React, { useState, useEffect } from 'react';
import { Spine } from '@esotericsoftware/spine-pixi-v8';
import { 
  PlayIcon, 
  PauseIcon, 
  StopIcon, 
  RewindIcon,
  ForwardIcon,
  ArrowPathIcon
} from './Icons';
import { IconButton } from './IconButton';

interface AnimationControlsProps {
  spineInstance: Spine;
}

export const AnimationControls: React.FC<AnimationControlsProps> = ({ spineInstance }) => {
  const [isPlaying, setIsPlaying] = useState(true);
  const [isLooping, setIsLooping] = useState(false);
  const [currentAnimation, setCurrentAnimation] = useState<string>('');
  const [animations, setAnimations] = useState<string[]>([]);
  const [currentTrack, setCurrentTrack] = useState(0);
  
  // Initialize animations list and set default animation
  useEffect(() => {
    if (!spineInstance) return;
    
    const animationNames = spineInstance.skeleton.data.animations.map(anim => anim.name);
    setAnimations(animationNames);
    
    if (animationNames.length > 0) {
      setCurrentAnimation(animationNames[0]);
      playAnimation(animationNames[0], false);
    }
    
    return () => {
      // Cleanup if needed
    };
  }, [spineInstance]);
  
  // Handle play/pause
  useEffect(() => {
    if (!spineInstance) return;
    
    if (isPlaying) {
      spineInstance.state.timeScale = 1;
    } else {
      spineInstance.state.timeScale = 0;
    }
  }, [isPlaying, spineInstance]);
  
  const playAnimation = (name: string, loop: boolean = isLooping) => {
    if (!spineInstance) return;
    
    spineInstance.state.setAnimation(currentTrack, name, loop);
    setCurrentAnimation(name);
    setIsPlaying(true);
  };
  
  const togglePlay = () => {
    setIsPlaying(!isPlaying);
  };
  
  const toggleLoop = () => {
    setIsLooping(!isLooping);
    
    // Reapply the current animation with new loop setting
    if (currentAnimation) {
      playAnimation(currentAnimation, !isLooping);
    }
  };
  
  const stopAnimation = () => {
    if (!spineInstance) return;
    
    spineInstance.state.clearTrack(currentTrack);
    setIsPlaying(false);
  };
  
  const rewindAnimation = () => {
    if (!spineInstance || !currentAnimation) return;
    
    // Restart the current animation
    playAnimation(currentAnimation);
  };
  
  const previousAnimation = () => {
    if (!spineInstance || animations.length === 0) return;
    
    const currentIndex = animations.indexOf(currentAnimation);
    const newIndex = currentIndex > 0 ? currentIndex - 1 : animations.length - 1;
    playAnimation(animations[newIndex]);
  };
  
  const nextAnimation = () => {
    if (!spineInstance || animations.length === 0) return;
    
    const currentIndex = animations.indexOf(currentAnimation);
    const newIndex = currentIndex < animations.length - 1 ? currentIndex + 1 : 0;
    playAnimation(animations[newIndex]);
  };
  
  return (
    <div className="animation-controls">
      <div className="animation-name">
        {currentAnimation}
      </div>
      
      <div className="playback-controls">
        <IconButton 
          icon={<RewindIcon />} 
          onClick={previousAnimation}
          tooltip="Previous Animation"
        />
        
        <IconButton 
          icon={<StopIcon />} 
          onClick={stopAnimation}
          tooltip="Stop"
        />
        
        <IconButton 
          icon={isPlaying ? <PauseIcon /> : <PlayIcon />} 
          onClick={togglePlay}
          tooltip={isPlaying ? "Pause" : "Play"}
        />
        
        <IconButton 
          icon={<ArrowPathIcon />} 
          onClick={rewindAnimation}
          tooltip="Restart Animation"
        />
        
        <IconButton 
          icon={<ForwardIcon />} 
          onClick={nextAnimation}
          tooltip="Next Animation"
        />
      </div>
      
      <div className="animation-settings">
        <label className="loop-toggle">
          <input
            type="checkbox"
            checked={isLooping}
            onChange={toggleLoop}
          />
          Loop
        </label>
        
        <select 
          value={currentAnimation}
          onChange={(e) => playAnimation(e.target.value)}
          className="animation-selector"
        >
          {animations.map(name => (
            <option key={name} value={name}>
              {name}
            </option>
          ))}
        </select>
      </div>
    </div>
  );
};
```


## src\components\ColorPicker.tsx

```
import React, { useState } from 'react';
import { SwatchIcon } from './Icons';
import { IconButton } from './IconButton';

interface ColorPickerProps {
  color: string;
  onChange: (color: string) => void;
}

export const ColorPicker: React.FC<ColorPickerProps> = ({ color, onChange }) => {
  const [isOpen, setIsOpen] = useState(false);
  
  const predefinedColors = [
    '#282b30', // Default dark
    '#1a1a1a', // Darker
    '#333333', // Dark gray
    '#121212', // Almost black
    '#2c2c2c', // Charcoal
    '#2b2d42', // Navy blue
    '#1d3557', // Dark blue
    '#3c096c', // Dark purple
    '#240046', // Deep purple
    '#1b263b', // Slate blue
  ];
  
  const togglePicker = () => {
    setIsOpen(!isOpen);
  };
  
  const handleColorSelect = (selectedColor: string) => {
    onChange(selectedColor);
    setIsOpen(false);
  };
  
  const handleCustomColorChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onChange(e.target.value);
  };
  
  return (
    <div className="color-picker-container">
      <IconButton 
        icon={<SwatchIcon />} 
        onClick={togglePicker}
        tooltip="Change Background Color"
        active={isOpen}
      />
      
      {isOpen && (
        <div className="color-picker-dropdown">
          <div className="color-picker-swatches">
            {predefinedColors.map((c, index) => (
              <button
                key={index}
                className={`color-swatch ${c === color ? 'active' : ''}`}
                style={{ backgroundColor: c }}
                onClick={() => handleColorSelect(c)}
                title={c}
              />
            ))}
          </div>
          
          <div className="color-picker-custom">
            <input
              type="color"
              value={color}
              onChange={handleCustomColorChange}
              title="Custom color"
            />
            <input 
              type="text"
              value={color}
              onChange={(e) => onChange(e.target.value)}
              pattern="^#[0-9A-Fa-f]{6}$"
              title="Hex color code (e.g. #282b30)"
            />
          </div>
        </div>
      )}
    </div>
  );
};
```


## src\components\IconButton.tsx

```
import React from 'react';

interface IconButtonProps {
  icon: React.ReactNode;
  onClick: () => void;
  tooltip?: string;
  active?: boolean;
  disabled?: boolean;
  className?: string;
}

export const IconButton: React.FC<IconButtonProps> = ({
  icon,
  onClick,
  tooltip,
  active = false,
  disabled = false,
  className = '',
}) => {
  return (
    <button
      className={`icon-button ${active ? 'active' : ''} ${disabled ? 'disabled' : ''} ${className}`}
      onClick={onClick}
      disabled={disabled}
      title={tooltip}
      aria-label={tooltip}
    >
      {icon}
    </button>
  );
};
```


## src\components\Icons.tsx

```
import React from 'react';

// Common SVG props that all icons share
interface IconProps {
  className?: string;
  size?: number;
}

const defaultProps = {
  className: '',
  size: 24,
};

// Helper function to create icon components
const createIcon = (path: React.ReactNode, viewBox = '0 0 24 24') => {
  return ({ className = '', size = 24 }: IconProps) => (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width={size}
      height={size}
      viewBox={viewBox}
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={`icon ${className}`}
      aria-hidden="true"
    >
      {path}
    </svg>
  );
};

// Document Icon
export const DocumentTextIcon = createIcon(
  <>
    <path d="M8 14H16M8 10H16M13 18H8C6.89543 18 6 17.1046 6 16V8C6 6.89543 6.89543 6 8 6H16C17.1046 6 18 6.89543 18 8V13" />
    <path d="M15 18L18 21M18 21L21 18M18 21V15" />
  </>
);

// Question Mark Circle Icon
export const QuestionMarkCircleIcon = createIcon(
  <>
    <circle cx="12" cy="12" r="10" />
    <path d="M12 16V16.01M12 13C12.5523 13 13 12.5523 13 12C13 11.4477 12.5523 11 12 11C11.4477 11 11 11.4477 11 12V12.5C11 12.7761 11.2239 13 11.5 13H12Z" />
  </>
);

// Play Icon
export const PlayIcon = createIcon(
  <path d="M5 3L19 12L5 21V3Z" />
);

// Pause Icon
export const PauseIcon = createIcon(
  <>
    <rect x="6" y="4" width="4" height="16" />
    <rect x="14" y="4" width="4" height="16" />
  </>
);

// Stop Icon
export const StopIcon = createIcon(
  <rect x="5" y="5" width="14" height="14" />
);

// Rewind Icon
export const RewindIcon = createIcon(
  <>
    <path d="M4 16V8L10 12L4 16Z" />
    <path d="M12 16V8L18 12L12 16Z" />
  </>
);

// Forward Icon
export const ForwardIcon = createIcon(
  <>
    <path d="M6 16V8L12 12L6 16Z" />
    <path d="M14 16V8L20 12L14 16Z" />
  </>
);

// Arrow Path (Refresh) Icon
export const ArrowPathIcon = createIcon(
  <path d="M16.023 9h4.977v-4M7.977 15h-4.977v4M16.5 7.5c-1.333-1.333-3.5-3-6.5-3-4.142 0-7.5 3.358-7.5 7.5 0 1.487.433 2.873 1.179 4.038M7.5 16.5c1.333 1.333 3.5 3 6.5 3 4.142 0 7.5-3.358 7.5-7.5 0-1.487-.433-2.873-1.179-4.038" />
);

// X Mark (Close) Icon
export const XMarkIcon = createIcon(
  <path d="M6 18L18 6M6 6L18 18" />
);

// Swatch (Color Palette) Icon
export const SwatchIcon = createIcon(
  <>
    <path d="M16.5 3.5a2.12 2.12 0 013 3L7 19l-4 1 1-4L16.5 3.5z" />
    <path d="M15 10l5 5" />
  </>
);

// Cog (Settings) Icon 
export const CogIcon = createIcon(
  <>
    <circle cx="12" cy="12" r="3" />
    <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z" />
  </>
);
```


## src\components\InfoPanel.tsx

```
import React, { useState } from 'react';
import { createPortal } from 'react-dom';
import { XMarkIcon } from './Icons';
import { IconButton } from './IconButton';
import { BenchmarkData } from '../hooks/useSpineApp';

interface InfoPanelProps {
  data: BenchmarkData;
  onClose: () => void;
}

export const InfoPanel: React.FC<InfoPanelProps> = ({ data, onClose }) => {
  const [activeTab, setActiveTab] = useState('summary');
  
  // Create a container for the portal if it doesn't exist
  const container = document.getElementById('info-panel-container') || (() => {
    const div = document.createElement('div');
    div.id = 'info-panel-container';
    document.body.appendChild(div);
    return div;
  })();
  
  const tabs = [
    { id: 'summary', label: 'Summary' },
    { id: 'meshAnalysis', label: 'Mesh Analysis' },
    { id: 'clippingAnalysis', label: 'Clipping' },
    { id: 'blendModeAnalysis', label: 'Blend Modes' },
    { id: 'skeletonTree', label: 'Skeleton Tree' },
  ];
  
  const renderTabContent = () => {
    switch (activeTab) {
      case 'summary':
        return (
          <div className="tab-content">
            <h3>Benchmark Summary</h3>
            <div dangerouslySetInnerHTML={{ __html: data.summary || '<p>No summary data available</p>' }} />
          </div>
        );
      case 'meshAnalysis':
        return (
          <div className="tab-content">
            <h3>Mesh Analysis</h3>
            <div dangerouslySetInnerHTML={{ __html: data.meshAnalysis || '<p>No mesh analysis data available</p>' }} />
          </div>
        );
      case 'clippingAnalysis':
        return (
          <div className="tab-content">
            <h3>Clipping Analysis</h3>
            <div dangerouslySetInnerHTML={{ __html: data.clippingAnalysis || '<p>No clipping analysis data available</p>' }} />
          </div>
        );
      case 'blendModeAnalysis':
        return (
          <div className="tab-content">
            <h3>Blend Mode Analysis</h3>
            <div dangerouslySetInnerHTML={{ __html: data.blendModeAnalysis || '<p>No blend mode analysis data available</p>' }} />
          </div>
        );
      case 'skeletonTree':
        return (
          <div className="tab-content">
            <h3>Skeleton Tree</h3>
            <div dangerouslySetInnerHTML={{ __html: data.skeletonTree || '<p>No skeleton tree data available</p>' }} />
          </div>
        );
      default:
        return <div>Select a tab to view benchmark information</div>;
    }
  };
  
  return createPortal(
    <div className="info-panel-backdrop">
      <div className="info-panel">
        <div className="info-panel-header">
          <h2>Spine Benchmark Analysis</h2>
          <IconButton 
            icon={<XMarkIcon />} 
            onClick={onClose}
            tooltip="Close"
          />
        </div>
        
        <div className="info-panel-tabs">
          {tabs.map(tab => (
            <button
              key={tab.id}
              className={`tab-button ${activeTab === tab.id ? 'active' : ''}`}
              onClick={() => setActiveTab(tab.id)}
            >
              {tab.label}
            </button>
          ))}
        </div>
        
        <div className="info-panel-content">
          {renderTabContent()}
        </div>
      </div>
    </div>,
    container
  );
};
```


## src\core\CameraContainer.ts

```
import { Application, Container } from "pixi.js";
import { Spine, SpineDebugRenderer } from "@esotericsoftware/spine-pixi-v8";
import gsap from "gsap";

export class CameraContainer extends Container {
  originalWidth: number;
  originalHeight: number;
  app: Application;
  isDragging: boolean = false;
  lastPosition: { x: number; y: number } | null = null;
  initialPosition: { x: number; y: number } | null = null;
  
  private isMeshVisible: boolean = false;
  private debugRenderer: SpineDebugRenderer | null = null;
  private currentSpine: Spine | null = null;
  
  constructor(options: { width: number; height: number; app: Application }) {
    super();
    this.originalWidth = options.width;
    this.originalHeight = options.height;
    this.app = options.app;
    this.debugRenderer = new SpineDebugRenderer();
    
    // Setup event listeners
    this.setupEventListeners();
    
    // Center the container initially
    this.x = this.app.renderer.width / 2;
    this.y = this.app.renderer.height / 2;
    
    // Listen for resize events
    window.addEventListener('resize', this.onResize.bind(this));
  }
  
  private setupEventListeners(): void {
    const view = this.app.view;
    
    if (!view) return;
    
    // Mouse down event for panning
    view.addEventListener('mousedown', (e: MouseEvent) => {
      if (e.button === 0) { // Left mouse button
        this.isDragging = true;
        this.lastPosition = { x: e.clientX, y: e.clientY };
        view.style.cursor = 'grabbing';
      }
    });
    
    // Mouse move event for panning
    window.addEventListener('mousemove', (e: MouseEvent) => {
      if (this.isDragging && this.lastPosition) {
        const dx = e.clientX - this.lastPosition.x;
        const dy = e.clientY - this.lastPosition.y;
        
        this.x += dx;
        this.y += dy;
        
        this.lastPosition = { x: e.clientX, y: e.clientY };
      }
    });
    
    // Mouse up event to stop panning
    window.addEventListener('mouseup', (e: MouseEvent) => {
      if (e.button === 0) { // Left mouse button
        this.isDragging = false;
        this.lastPosition = null;
        view.style.cursor = 'default';
      }
    });
    
    // Mouse wheel event for zooming
    view.addEventListener('wheel', (e: WheelEvent) => {
      e.preventDefault();
      
      // Determine scroll direction
      const scrollDirection = Math.sign(e.deltaY);
      
      // Calculate new scale
      const minScale = 0.2;
      const maxScale = 10;
      const scaleStep = 0.1;
      
      let newScale = this.scale.x - scrollDirection * scaleStep;
      newScale = Math.max(minScale, Math.min(maxScale, newScale));
      newScale = Number((Math.ceil(newScale * 20) / 20).toFixed(2));
      
      // Apply the new scale
      this.scale.set(newScale);
      
      // Update scale info if needed
      this.setCanvasScaleDebugInfo(newScale);
    });
  }
  
  public onResize(): void {
    // Center the container on resize
    this.x = this.app.renderer.width / 2;
    this.y = this.app.renderer.height / 2;
  }
  
  public lookAtChild(spine: Spine): void {
    this.currentSpine = spine;
    
    // Register spine with debug renderer
    if (this.debugRenderer) {
      this.debugRenderer.registerSpine(spine);
      
      // Add ticker for debug rendering
      this.app.ticker.add(() => {
        if (this.currentSpine && this.debugRenderer) {
          if (this.isMeshVisible) {
            this.debugRenderer.renderDebug(this.currentSpine);
          } else {
            this.clearDebugRendering();
          }
        }
      });
    }
    
    // Calculate padding
    const padding = 20;
    
    // Get the bounds of the object in global space
    let bounds = spine.getBounds();
    if (bounds.width === 0 || bounds.height === 0) {
      bounds.width = spine.skeleton.data.width / 2;
      bounds.height = spine.skeleton.data.height / 2;
    }
    
    // Calculate the scale needed to fit the object within the screen
    const scaleX = (this.app.screen.width - padding * 2) / bounds.width;
    const scaleY = (this.app.screen.height - padding * 2) / bounds.height;
    let scale = Math.min(scaleX, scaleY);
    
    // Set spine scale
    spine.scale.set(1);
    
    // Calculate the position to center the object
    const x = this.app.screen.width / 2;
    const y = this.app.screen.height / 2;
    
    // Animate the camera to look at the object
    gsap.to(this, {
      x,
      y,
      duration: 1,
      ease: "power2.out",
    });
    
    // Round the scale for cleaner display
    scale = Number((Math.ceil(scale * 20) / 20).toFixed(2));
    this.scale.set(scale);
    this.setCanvasScaleDebugInfo(scale);
  }
  
  private clearDebugRendering(): void {
    if (!this.debugRenderer || !this.currentSpine) return;
    
    const debugDisplayObjects = this.debugRenderer['registeredSpines'].get(this.currentSpine);
    if (!debugDisplayObjects) return;
    
    debugDisplayObjects.skeletonXY.clear();
    debugDisplayObjects.regionAttachmentsShape.clear();
    debugDisplayObjects.meshTrianglesLine.clear();
    debugDisplayObjects.meshHullLine.clear();
    debugDisplayObjects.clippingPolygon.clear();
    debugDisplayObjects.boundingBoxesRect.clear();
    debugDisplayObjects.boundingBoxesCircle.clear();
    debugDisplayObjects.boundingBoxesPolygon.clear();
    debugDisplayObjects.pathsCurve.clear();
    debugDisplayObjects.pathsLine.clear();
    
    for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {
      debugDisplayObjects.bones.children[len - 1].destroy({ children: true });
    }
  }
  
  private setCanvasScaleDebugInfo(scale: number): void {
    // This would be handled by a React component in our new architecture
    const scaleInfo = document.getElementById("scale-info");
    if (scaleInfo) {
      scaleInfo.innerText = `Scale: x${scale.toFixed(2)}`;
    }
  }
  
  public setMeshVisibility(isVisible: boolean): void {
    this.isMeshVisible = isVisible;
  }
  
  public getMeshVisibility(): boolean {
    return this.isMeshVisible;
  }
  
  // Center the view
  public centerViewport(): void {
    const w = this.app.renderer.width;
    const h = this.app.renderer.height;
    
    gsap.to(this, {
      x: w / 2,
      y: h / 2,
      duration: 0.5,
      ease: "power2.out",
    });
  }
  
  public override destroy(): void {
    // Remove event listeners
    window.removeEventListener('resize', this.onResize);
    
    // Cleanup ticker
    this.app.ticker.remove(() => {
      if (this.currentSpine && this.debugRenderer) {
        this.debugRenderer.renderDebug(this.currentSpine);
      }
    });
    
    // Call parent destroy method
    super.destroy();
  }
}
```


## src\core\SpineAnalyzer.ts

```
import { Spine, MeshAttachment, ClippingAttachment, DeformTimeline, BlendMode } from "@esotericsoftware/spine-pixi-v8";
import { BenchmarkData } from "../hooks/useSpineApp";

export class SpineAnalyzer {
  static analyze(spineInstance: Spine): BenchmarkData {
    const meshAnalysis = this.analyzeMeshes(spineInstance);
    const clippingAnalysis = this.analyzeClipping(spineInstance);
    const blendModeAnalysis = this.analyzeBlendModes(spineInstance);
    const skeletonTree = this.createSkeletonTree(spineInstance);
    
    // Generate summary combining the most important metrics
    const summary = this.generateSummary(spineInstance, {
      meshAnalysis,
      clippingAnalysis,
      blendModeAnalysis
    });
    
    return {
      meshAnalysis,
      clippingAnalysis,
      blendModeAnalysis,
      skeletonTree,
      summary
    };
  }
  
  private static analyzeMeshes(spineInstance: Spine): string {
    const skeleton = spineInstance.skeleton;
    const animations = spineInstance.skeleton.data.animations;

    let totalMeshCount = 0;
    const meshesWithChangesInTimelines = new Map();
    const meshWorldVerticesLengths = new Map<string, number>();
    const meshesWithBoneWeights = new Map<string, number>();
    const meshesWithParents = new Map<string, boolean>();
    
    // Count total meshes and analyze properties
    skeleton.slots.forEach((slot) => {
      const attachment = slot.getAttachment();
      if (attachment && attachment instanceof MeshAttachment) {
        totalMeshCount++;
        
        if (attachment.bones?.length) {
          meshesWithBoneWeights.set(slot.data.name, attachment.bones.length);
        }
        
        meshWorldVerticesLengths.set(
          slot.data.name,
          attachment.worldVerticesLength
        );
        
        meshesWithChangesInTimelines.set(slot.data.name, false);
        meshesWithParents.set(slot.data.name, attachment.getParentMesh() != null);
      }
    });
    
    // Analyze animations for mesh changes
    animations.forEach((animation) => {
      const timelines = animation.timelines;
      timelines.forEach((timeline) => {
        if (timeline instanceof DeformTimeline) {
          const slotIndex = timeline.slotIndex;
          const slot = skeleton.slots[slotIndex];
          const attachment = slot.getAttachment();
          
          if (attachment && attachment instanceof MeshAttachment) {
            meshesWithChangesInTimelines.set(slot.data.name, true);
          }
        }
      });
    });
    
    // Convert to array for easier rendering in table
    const meshData = Array.from(meshWorldVerticesLengths.keys()).map(key => ({
      slotName: key,
      vertices: meshWorldVerticesLengths.get(key) || 0,
      isDeformed: meshesWithChangesInTimelines.get(key) || false,
      boneWeights: meshesWithBoneWeights.get(key) || 0,
      hasParentMesh: meshesWithParents.get(key) || false
    }));
    
    // Sort by vertex count descending
    meshData.sort((a, b) => b.vertices - a.vertices);
    
    // Generate HTML for table
    let html = `
      <div class="mesh-analysis">
        <h3>Mesh Statistics</h3>
        <p>Total meshes: ${totalMeshCount}</p>
        <p>Meshes with deformation: ${Array.from(meshesWithChangesInTimelines.values()).filter(Boolean).length}</p>
        <p>Meshes with bone weights: ${meshesWithBoneWeights.size}</p>
        <p>Meshes with parent mesh: ${Array.from(meshesWithParents.values()).filter(Boolean).length}</p>
        
        <table class="benchmark-table">
          <thead>
            <tr>
              <th>Slot</th>
              <th>Vertices</th>
              <th>Deformed</th>
              <th>Bone Weights</th>
              <th>Has Parent Mesh</th>
            </tr>
          </thead>
          <tbody>
    `;
    
    meshData.forEach(item => {
      // Determine row color based on vertex count and deformation
      let rowClass = '';
      if (item.vertices > 100) {
        rowClass = 'row-danger';
      } else if (item.vertices > 64) {
        rowClass = 'row-warning';
      }
      
      html += `
        <tr class="${rowClass}">
          <td>${item.slotName}</td>
          <td>${item.vertices}</td>
          <td>${item.isDeformed ? 'Yes' : 'No'}</td>
          <td>${item.boneWeights}</td>
          <td>${item.hasParentMesh ? 'Yes' : 'No'}</td>
        </tr>
      `;
    });
    
    html += `
          </tbody>
        </table>
      </div>
    `;
    
    return html;
  }
  
  private static analyzeClipping(spineInstance: Spine): string {
    const masks: [string, number][] = [];
    
    spineInstance.skeleton.slots.forEach((slot) => {
      if (slot.attachment && slot.attachment instanceof ClippingAttachment) {
        const clipping = slot.attachment as ClippingAttachment;
        const verticesCount = clipping.worldVerticesLength / 2; // Divide by 2 because each vertex has x and y
        masks.push([slot.data.name, verticesCount]);
      }
    });
    
    let html = `
      <div class="clipping-analysis">
        <h3>Clipping Masks</h3>
        <p>Total masks: ${masks.length}</p>
    `;
    
    if (masks.length > 0) {
      html += `
        <table class="benchmark-table">
          <thead>
            <tr>
              <th>Slot Name</th>
              <th>Vertex Count</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>
      `;
      
      masks.forEach(([slotName, vertexCount]) => {
        const status = vertexCount <= 4 
          ? 'Optimal' 
          : vertexCount <= 8 
            ? 'Acceptable' 
            : 'High Vertex Count';
        
        const rowClass = vertexCount <= 4 
          ? '' 
          : vertexCount <= 8 
            ? 'row-warning' 
            : 'row-danger';
        
        html += `
          <tr class="${rowClass}">
            <td>${slotName}</td>
            <td>${vertexCount}</td>
            <td>${status}</td>
          </tr>
        `;
      });
      
      html += `
          </tbody>
        </table>
        
        <div class="analysis-notes">
          <h4>Notes on Clipping Masks:</h4>
          <ul>
            <li>Clipping masks with 3-4 vertices are the most efficient</li>
            <li>Complex masks with many vertices can significantly impact performance</li>
            <li>Consider simplifying masks with more than 8 vertices</li>
          </ul>
        </div>
      `;
    } else {
      html += `<p>No clipping masks found in this skeleton.</p>`;
    }
    
    html += `</div>`;
    
    return html;
  }
  
  private static analyzeBlendModes(spineInstance: Spine): string {
    const blendModeCount = new Map<BlendMode, number>();
    const slotsWithNonNormalBlendMode = new Map<string, BlendMode>();
    
    // Initialize blend mode counts
    Object.values(BlendMode).forEach(mode => {
      if (typeof mode === 'number') {
        blendModeCount.set(mode as BlendMode, 0);
      }
    });
    
    // Count blend modes
    spineInstance.skeleton.slots.forEach(slot => {
      const blendMode = slot.data.blendMode;
      blendModeCount.set(blendMode, (blendModeCount.get(blendMode) || 0) + 1);
      
      if (blendMode !== BlendMode.Normal) {
        slotsWithNonNormalBlendMode.set(slot.data.name, blendMode);
      }
    });
    
    let html = `
      <div class="blend-mode-analysis">
        <h3>Blend Modes</h3>
        <p>Non-normal blend modes: ${slotsWithNonNormalBlendMode.size}</p>
        
        <table class="benchmark-table">
          <thead>
            <tr>
              <th>Blend Mode</th>
              <th>Count</th>
            </tr>
          </thead>
          <tbody>
    `;
    
    // Sort by frequency
    const sortedCounts = Array.from(blendModeCount.entries())
      .sort((a, b) => b[1] - a[1]);
    
    sortedCounts.forEach(([mode, count]) => {
      if (count > 0) {
        const modeName = BlendMode[mode];
        const rowClass = mode !== BlendMode.Normal && count > 0 
          ? 'row-warning' 
          : '';
        
        html += `
          <tr class="${rowClass}">
            <td>${modeName}</td>
            <td>${count}</td>
          </tr>
        `;
      }
    });
    
    html += `
          </tbody>
        </table>
    `;
    
    if (slotsWithNonNormalBlendMode.size > 0) {
      html += `
        <h4>Slots with Non-Normal Blend Modes:</h4>
        <table class="benchmark-table">
          <thead>
            <tr>
              <th>Slot Name</th>
              <th>Blend Mode</th>
            </tr>
          </thead>
          <tbody>
      `;
      
      slotsWithNonNormalBlendMode.forEach((mode, slotName) => {
        html += `
          <tr>
            <td>${slotName}</td>
            <td>${BlendMode[mode]}</td>
          </tr>
        `;
      });
      
      html += `
          </tbody>
        </table>
        
        <div class="analysis-notes">
          <h4>Notes on Blend Modes:</h4>
          <ul>
            <li>Non-normal blend modes (Add, Multiply) cause additional rendering passes</li>
            <li>Try to limit the number of slots with non-normal blend modes</li>
            <li>Group slots with the same blend mode together when possible</li>
          </ul>
        </div>
      `;
    }
    
    html += `</div>`;
    
    return html;
  }
  
  private static createSkeletonTree(spineInstance: Spine): string {
    const skeleton = spineInstance.skeleton;
    
    // Generate tree structure
    function buildBoneNode(bone: any): any {
      const children = bone.children || [];
      return {
        name: bone.data.name,
        type: 'bone',
        x: bone.x.toFixed(2),
        y: bone.y.toFixed(2),
        children: children.map(buildBoneNode)
      };
    }
    
    const rootBones = skeleton.bones.filter(bone => !bone.parent);
    const boneTree = rootBones.map(buildBoneNode);
    
    // Generate HTML for the tree
    function generateTreeHTML(nodes: any[]): string {
      if (nodes.length === 0) return '';
      
      let html = '<ul class="skeleton-tree">';
      
      nodes.forEach(node => {
        html += `<li class="tree-node">
          <span class="node-label">${node.name} (x: ${node.x}, y: ${node.y})</span>`;
        
        if (node.children && node.children.length > 0) {
          html += generateTreeHTML(node.children);
        }
        
        html += '</li>';
      });
      
      html += '</ul>';
      return html;
    }
    
    let html = `
      <div class="skeleton-tree-container">
        <h3>Skeleton Structure</h3>
        <p>Total bones: ${skeleton.bones.length}</p>
        <p>Root bones: ${rootBones.length}</p>
        <p>Max depth: ${this.calculateMaxDepth(boneTree)}</p>
        
        <div class="tree-view">
          ${generateTreeHTML(boneTree)}
        </div>
      </div>
    `;
    
    return html;
  }
  
  private static calculateMaxDepth(nodes: any[]): number {
    if (!nodes || nodes.length === 0) return 0;
    
    return 1 + Math.max(...nodes.map(node => 
      node.children ? this.calculateMaxDepth(node.children) : 0
    ));
  }
  
  private static generateSummary(
    spineInstance: Spine, 
    analyses: { 
      meshAnalysis: string; 
      clippingAnalysis: string; 
      blendModeAnalysis: string;
    }
  ): string {
    const skeleton = spineInstance.skeleton;
    
    // Calculate overall stats
    const totalBones = skeleton.bones.length;
    const totalSlots = skeleton.slots.length;
    const totalMeshes = skeleton.slots.filter(slot => 
      slot.getAttachment() instanceof MeshAttachment
    ).length;
    const totalClippings = skeleton.slots.filter(slot => 
      slot.getAttachment() instanceof ClippingAttachment
    ).length;
    const nonNormalBlendModes = skeleton.slots.filter(slot => 
      slot.data.blendMode !== BlendMode.Normal
    ).length;
    
    // Evaluate performance concerns
    let performanceConcerns = [];
    let optimizationTips = [];
    
    // Mesh concerns
    if (totalMeshes > 20) {
      performanceConcerns.push('High number of meshes');
      optimizationTips.push('Consider reducing the number of meshes');
    }
    
    // Bone concerns
    if (totalBones > 50) {
      performanceConcerns.push('High number of bones');
      optimizationTips.push('Simplify skeleton hierarchy if possible');
    }
    
    // Clipping concerns
    if (totalClippings > 3) {
      performanceConcerns.push('Multiple clipping masks');
      optimizationTips.push('Reduce the number of clipping masks');
    }
    
    // Blend mode concerns
    if (nonNormalBlendModes > 4) {
      performanceConcerns.push('Many non-normal blend modes');
      optimizationTips.push('Limit the use of Add and Multiply blend modes');
    }
    
    // Generate performance score (simplified version)
    let performanceScore = 100;
    performanceScore -= totalBones > 50 ? 10 : 0;
    performanceScore -= totalMeshes > 20 ? 15 : 0;
    performanceScore -= totalClippings * 5;
    performanceScore -= nonNormalBlendModes * 3;
    
    // Cap the score
    performanceScore = Math.max(0, Math.min(100, performanceScore));
    
    // Determine score color
    let scoreColor = performanceScore >= 80 
      ? 'green' 
      : performanceScore >= 60 
        ? 'orange' 
        : 'red';
    
    let html = `
      <div class="benchmark-summary">
        <h3>Performance Summary</h3>
        
        <div class="score-container">
          <div class="performance-score" style="color: ${scoreColor}">
            ${performanceScore}
          </div>
          <div class="score-label">Performance Score</div>
        </div>
        
        <div class="skeleton-stats">
          <h4>Skeleton Statistics</h4>
          <table class="stats-table">
            <tr>
              <td>Bones:</td>
              <td>${totalBones}</td>
            </tr>
            <tr>
              <td>Slots:</td>
              <td>${totalSlots}</td>
            </tr>
            <tr>
              <td>Meshes:</td>
              <td>${totalMeshes}</td>
            </tr>
            <tr>
              <td>Clipping Masks:</td>
              <td>${totalClippings}</td>
            </tr>
            <tr>
              <td>Non-Normal Blend Modes:</td>
              <td>${nonNormalBlendModes}</td>
            </tr>
          </table>
        </div>
    `;
    
    if (performanceConcerns.length > 0) {
      html += `
        <div class="performance-concerns">
          <h4>Performance Concerns</h4>
          <ul>
            ${performanceConcerns.map(concern => `<li>${concern}</li>`).join('')}
          </ul>
        </div>
      `;
    }
    
    if (optimizationTips.length > 0) {
      html += `
        <div class="optimization-tips">
          <h4>Optimization Tips</h4>
          <ul>
            ${optimizationTips.map(tip => `<li>${tip}</li>`).join('')}
          </ul>
        </div>
      `;
    }
    
    html += `
      </div>
    `;
    
    return html;
  }
}
```


## src\core\SpineLoader.ts

```
import { Application, Assets, Texture } from 'pixi.js';
import {
  AtlasAttachmentLoader,
  SkeletonJson,
  Spine,
  SpineTexture,
  TextureAtlas,
} from '@esotericsoftware/spine-pixi-v8';
import { createId } from '@paralleldrive/cuid2';

export class SpineLoader {
  private app: Application;

  constructor(app: Application) {
    this.app = app;
  }

  public async loadSpineFiles(files: FileList): Promise<Spine | null> {
    try {
      const acceptedFiles = Array.from(files);
      console.log('Processing files:', acceptedFiles.map(f => (f as any).fullPath || f.name).join(', '));
      
      // Initialize tracking variables
      let atlasFile: File | undefined;
      let jsonFile: File | undefined;
      let skelFile: File | undefined;
      let imageFiles: File[] = [];
      
      // First pass - categorize files
      acceptedFiles.forEach((file) => {
        const fileName = file.name;
        const fullPath = (file as any).fullPath || file.name;
        
        if (fileName.endsWith('.atlas')) {
          atlasFile = file;
          console.log("Atlas file found:", fullPath);
        } else if (fileName.endsWith('.json')) {
          jsonFile = file;
          console.log("JSON file found:", fullPath);
        } else if (fileName.endsWith('.skel')) {
          skelFile = file;
          console.log("Skel file found:", fullPath);
        } else if (file.type.startsWith('image/') || 
                  fileName.endsWith('.png') || 
                  fileName.endsWith('.jpg') ||
                  fileName.endsWith('.jpeg') || 
                  fileName.endsWith('.webp')) {
          imageFiles.push(file);
          console.log("Image file found:", fullPath);
        } else {
          console.log("Unrecognized file type:", fullPath);
        }
      });
      
      // Validate required files
      if (!atlasFile) {
        throw new Error('Missing atlas file (.atlas). Please include an atlas file with your Spine data.');
      }
      
      if (!jsonFile && !skelFile) {
        throw new Error('Missing skeleton file (.json or .skel). Please include a skeleton file with your Spine data.');
      }
      
      if (imageFiles.length === 0) {
        throw new Error('Missing image files. Please include image files referenced by your atlas.');
      }
      
      // Read atlas content
      const atlasText = await this.readFileAsText(atlasFile);
      
      // Load skeleton data
      let skeletonData;
      const isBinary = !!skelFile;
      
      if (skelFile) {
        // Binary format
        skeletonData = await this.readFileAsArrayBuffer(skelFile);
      } else if (jsonFile) {
        // JSON format
        const jsonText = await this.readFileAsText(jsonFile);
        try {
          skeletonData = JSON.parse(jsonText);
          
          // Check for Spine 4.1 vs 4.2 version
          if (skeletonData && skeletonData.spine && skeletonData.spine.startsWith('4.1')) {
            console.log('Updating Spine version from 4.1 to 4.2.0');
            skeletonData.spine = '4.2.0';
          }
        } catch (error) {
          console.error("Error parsing JSON:", error);
          throw new Error("Invalid JSON format in skeleton file");
        }
      }
      
      // Extract image names from atlas
      const imageNames = this.extractImageNamesFromAtlas(atlasText);
      console.log("Image names referenced in atlas:", imageNames);
      
      // Create asset bundle
      const assetBundle: Record<string, any> = {};
      
      // Process each image file
      for (const imageFile of imageFiles) {
        const base64 = await this.fileToBase64(imageFile);
        const fileName = this.getFileName(imageFile.name);
        
        // Store with filename as key
        assetBundle[fileName] = {
          src: base64,
          data: { type: imageFile.type || 'image/png' }
        };
        
        // Also store without extension for better matching
        const fileNameWithoutExt = fileName.substring(0, fileName.lastIndexOf('.'));
        if (fileNameWithoutExt) {
          assetBundle[fileNameWithoutExt] = {
            src: base64,
            data: { type: imageFile.type || 'image/png' }
          };
        }
      }
      
      // Load textures
      Assets.addBundle('spineAssets', assetBundle);
      const textures = await Assets.loadBundle('spineAssets');
      
      // Create spine asset
      return await this.createSpineAsset(skeletonData, atlasText, textures, isBinary);
      
    } catch (error) {
      console.error('Error loading Spine files:', error);
      throw error;
    }
  }

  private getFileName(path: string): string {
    // Extract just the filename without path
    return path.split('/').pop() || path;
  }
  
  private extractImageNamesFromAtlas(atlasText: string): string[] {
    const lines = atlasText.split('\n');
    const imageNames: string[] = [];
    
    // In spine atlas format, the image names are the first non-empty lines 
    // before each "size:" line
    let currentName = '';
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      if (line === '') continue;
      
      if (line.startsWith('size:')) {
        if (currentName && !imageNames.includes(currentName)) {
          imageNames.push(currentName);
        }
        currentName = '';
      } else if (currentName === '') {
        // If we don't have a current name and this line is not a property,
        // it must be an image name
        if (!line.includes(':')) {
          currentName = line;
        }
      }
    }
    
    // Add the last image name if we have one
    if (currentName && !imageNames.includes(currentName)) {
      imageNames.push(currentName);
    }
    
    return imageNames;
  }
  
  private fileToBase64(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as string);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  private readFileAsText(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as string);
      reader.onerror = reject;
      reader.readAsText(file);
    });
  }

  private readFileAsArrayBuffer(file: File): Promise<ArrayBuffer> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as ArrayBuffer);
      reader.onerror = reject;
      reader.readAsArrayBuffer(file);
    });
  }

  private async createSpineAsset(
    data: any, 
    atlasText: string, 
    textures: Record<string, Texture>,
    isBinary: boolean
  ): Promise<Spine> {
    console.log("Creating Spine Asset");

    // Create atlas
    const spineAtlas = new TextureAtlas(atlasText);
    
    // Process each page in the atlas
    for (const page of spineAtlas.pages) {
      const pageName = page.name;
      
      // Try different ways to match the texture
      let texture = textures[pageName];
      
      if (!texture) {
        // Try without path
        const baseFileName = this.getFileName(pageName);
        texture = textures[baseFileName];
        
        if (!texture) {
          // Try without extension
          const baseNameWithoutExt = baseFileName.substring(0, baseFileName.lastIndexOf('.'));
          if (baseNameWithoutExt) {
            texture = textures[baseNameWithoutExt];
          }
        }
      }

      if (!texture) {
        console.error(`Missing texture for page: ${pageName}`);
        console.log("Available textures:", Object.keys(textures).join(", "));
        throw new Error(`Missing texture for page: ${pageName}`);
      }

      // Create SpineTexture from the PIXI Texture
      const spineTexture = SpineTexture.from(texture.source);
      
      // Set the texture for the page
      page.setTexture(spineTexture);
    }

    // Create attachment loader
    const atlasLoader = new AtlasAttachmentLoader(spineAtlas);

    // Create skeleton data
    const skeletonJson = new SkeletonJson(atlasLoader);
    const skeletonData = skeletonJson.readSkeletonData(data);

    // Create spine instance
    return new Spine(skeletonData);
  }
}
```


## src\error.ts

```
export enum SpineErrorCode {
    FILE_READ_ERROR = 1001,
    IMAGE_LOAD_ERROR = 1002,
    JSON_PARSE_ERROR = 1003,
    UNSUPPORTED_VERSION = 1004,
    INVALID_SKELETON_STRUCTURE = 1005,
    BINARY_FILE_ERROR = 1006,
    ATLAS_READ_ERROR = 1007,
    INVALID_ATLAS_STRUCTURE = 1008,
    TEXTURE_NOT_FOUND = 1009,
    ATLAS_CREATE_ERROR = 1010,
    EMPTY_SKELETON = 1011,
    SKELETON_PARSE_ERROR = 1012,
    SPINE_INSTANCE_ERROR = 1013,
    CRITICAL_ASSET_ERROR = 1014,
    FILE_PROCESSING_ERROR = 1015,
    MISSING_SKELETON_FILE = 1016,
    MISSING_ATLAS_FILE = 1017,
  }
  
  interface SpineError {
    code: SpineErrorCode;
    message: string;
  }
  
  export class SpineErrorHandler extends Error {
    code: SpineErrorCode;
  
    constructor(error: SpineError) {
      super(error.message);
      this.code = error.code;
      this.name = "SpineError";
    }
  }
  
  export const SPINE_ERRORS: Record<SpineErrorCode, string> = {
    [SpineErrorCode.FILE_READ_ERROR]: "Ошибка чтения файла: {0}",
    [SpineErrorCode.IMAGE_LOAD_ERROR]: "Ошибка загрузки изображения {0}: {1}",
    [SpineErrorCode.JSON_PARSE_ERROR]:
      "Ошибка парсинга JSON файла скелета {0}: {1}",
    [SpineErrorCode.UNSUPPORTED_VERSION]:
      "Неподдерживаемая версия Spine: {0}. Максимальная поддерживаемая версия: 4.1",
    [SpineErrorCode.INVALID_SKELETON_STRUCTURE]:
      "Некорректная структура JSON файла скелета: {0}",
    [SpineErrorCode.BINARY_FILE_ERROR]:
      "Ошибка чтения бинарного файла скелета: {0}",
    [SpineErrorCode.ATLAS_READ_ERROR]: "Ошибка чтения файла атласа: {0}",
    [SpineErrorCode.INVALID_ATLAS_STRUCTURE]:
      "Некорректная структура файла атласа: {0}",
    [SpineErrorCode.TEXTURE_NOT_FOUND]: "Текстура не найдена: {0}",
    [SpineErrorCode.ATLAS_CREATE_ERROR]: "Ошибка создания атласа: {0}",
    [SpineErrorCode.EMPTY_SKELETON]: "Скелет не содержит костей",
    [SpineErrorCode.SKELETON_PARSE_ERROR]: "Ошибка парсинга скелета: {0}",
    [SpineErrorCode.SPINE_INSTANCE_ERROR]:
      "Ошибка создания экземпляра Spine: {0}",
    [SpineErrorCode.CRITICAL_ASSET_ERROR]:
      "Критическая ошибка при создании ассета: {0}",
    [SpineErrorCode.FILE_PROCESSING_ERROR]:
      "Произошла ошибка при обработке файла {0}: {1}",
    [SpineErrorCode.MISSING_SKELETON_FILE]:
      "Отсутствует файл скелета (.json или .skel). Загрузите файл скелета вместе с атласом.",
    [SpineErrorCode.MISSING_ATLAS_FILE]:
      "Отсутствует атлас файл (.atlas). Загрузите его вместе со скелетом.",
  };
  
  export function formatErrorMessage(
    code: SpineErrorCode,
    ...args: string[]
  ): string {
    let message = SPINE_ERRORS[code];
    args.forEach((arg, index) => {
      message = message.replace(`{${index}}`, arg);
    });
    return message;
  }
```


## src\hooks\ToastContext.tsx

```
import React, { createContext, useContext } from 'react';
import { toast, ToastContainer as ToastifyContainer, ToastOptions } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

export type ToastType = 'info' | 'success' | 'warning' | 'error';

interface ToastContextType {
  addToast: (message: string, type?: ToastType) => void;
}

const ToastContext = createContext<ToastContextType | undefined>(undefined);

// Configure default toast options
const toastOptions: ToastOptions = {
  position: "top-center",
  autoClose: 1000,
  hideProgressBar: false,
  closeOnClick: true,
  pauseOnHover: true,
  draggable: true,
  progress: undefined,
  theme: "dark",
};

export const ToastProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const addToast = (message: string, type: ToastType = 'info') => {
    switch (type) {
      case 'success':
        toast.success(message, toastOptions);
        break;
      case 'warning':
        toast.warning(message, toastOptions);
        break;
      case 'error':
        toast.error(message, toastOptions);
        break;
      case 'info':
      default:
        toast.info(message, toastOptions);
    }
  };

  return (
    <ToastContext.Provider value={{ addToast }}>
      {children}
    </ToastContext.Provider>
  );
};

export const useToast = () => {
  const context = useContext(ToastContext);
  if (context === undefined) {
    throw new Error('useToast must be used within a ToastProvider');
  }
  return context;
};

// Custom ToastContainer component with dark theme
export const ToastContainer: React.FC = () => {
  return (
    <ToastifyContainer
      position="top-center"
      autoClose={1000}
      hideProgressBar={false}
      newestOnTop
      closeOnClick
      rtl={false}
      pauseOnFocusLoss
      draggable
      pauseOnHover
      theme="dark"
    />
  );
};
```


## src\hooks\useSafeLocalStorage.ts

```
import { useState, useEffect, Dispatch, SetStateAction } from 'react';

export function useSafeLocalStorage<T>(
  key: string, 
  initialValue: T
): [T, Dispatch<SetStateAction<T>>] {
  // State to store our value
  const [storedValue, setStoredValue] = useState<T>(initialValue);

  // Function to safely access localStorage
  const isLocalStorageAvailable = (): boolean => {
    try {
      const testKey = '__test__';
      localStorage.setItem(testKey, testKey);
      localStorage.removeItem(testKey);
      return true;
    } catch (e) {
      return false;
    }
  };

  // Initialize stored value from localStorage if available
  useEffect(() => {
    try {
      if (!isLocalStorageAvailable()) return;
      
      const item = localStorage.getItem(key);
      if (item !== null) {
        setStoredValue(JSON.parse(item));
      }
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
    }
  }, [key]);

  // Return a wrapped version of useState's setter function that
  // persists the new value to localStorage.
  const setValue: Dispatch<SetStateAction<T>> = (value) => {
    try {
      // Allow value to be a function so we have same API as useState
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      
      // Save state
      setStoredValue(valueToStore);
      
      // Save to localStorage if available
      if (isLocalStorageAvailable()) {
        localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.warn(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue];
}
```


## src\hooks\useSpineApp.ts

```
import { useState, useRef, useEffect } from 'react';
import { Application } from 'pixi.js';
import { Spine } from '@esotericsoftware/spine-pixi-v8';
import { CameraContainer } from '../core/CameraContainer';
import { SpineLoader } from '../core/SpineLoader';
import { SpineAnalyzer } from '../core/SpineAnalyzer';
import { useToast } from './ToastContext';

export interface BenchmarkData {
  meshAnalysis: any;
  clippingAnalysis: any;
  blendModeAnalysis: any;
  skeletonTree: any;
  summary: any;
}

export function useSpineApp(app: Application | null) {
  const [spineInstance, setSpineInstance] = useState<Spine | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [benchmarkData, setBenchmarkData] = useState<BenchmarkData | null>(null);
  const cameraContainerRef = useRef<CameraContainer | null>(null);
  const { addToast } = useToast();

  // This effect runs when the app instance changes
  useEffect(() => {
    if (!app) return;

    // Create and add camera container
    const cameraContainer = new CameraContainer({
      width: app.screen.width,
      height: app.screen.height,
      app,
    });
    
    app.stage.addChild(cameraContainer);
    cameraContainerRef.current = cameraContainer;

    return () => {
      if (cameraContainer) {
        cameraContainer.destroy();
      }
      cameraContainerRef.current = null;
    };
  }, [app]);

  // Function to load spine files
  const loadSpineFiles = async (files: FileList) => {
    if (!app || !cameraContainerRef.current) {
      addToast('Application not initialized', 'error');
      return;
    }

    setIsLoading(true);
    
    try {
      // Log file information for debugging
      console.log(`Processing ${files.length} files:`);
      Array.from(files).forEach((file, index) => {
        console.log(`File ${index + 1}: ${file.name} (${file.type})`);
      });
      
      // Check if we have the basic required files
      const hasJsonFile = Array.from(files).some(file => 
        file.name.endsWith('.json') || file.type === 'application/json'
      );
      
      const hasSkelFile = Array.from(files).some(file => 
        file.name.endsWith('.skel')
      );
      
      const hasAtlasFile = Array.from(files).some(file => 
        file.name.endsWith('.atlas')
      );
      
      const hasImageFiles = Array.from(files).some(file => 
        file.type.startsWith('image/') || 
        file.name.endsWith('.png') || 
        file.name.endsWith('.jpg') || 
        file.name.endsWith('.jpeg') || 
        file.name.endsWith('.webp')
      );
      
      if (!hasAtlasFile) {
        throw new Error('Missing .atlas file. Please include an atlas file with your Spine data.');
      }
      
      if (!hasJsonFile && !hasSkelFile) {
        throw new Error('Missing skeleton file (.json or .skel). Please include a skeleton file with your Spine data.');
      }
      
      if (!hasImageFiles) {
        throw new Error('Missing image files. Please include image files referenced by your atlas.');
      }

      // Remove previous Spine instance if exists
      if (spineInstance) {
        cameraContainerRef.current.removeChild(spineInstance);
        setSpineInstance(null);
      }

      // Load spine files
      const loader = new SpineLoader(app);
      const newSpineInstance = await loader.loadSpineFiles(files);
      
      if (!newSpineInstance) {
        throw new Error('Failed to load Spine instance');
      }

      // Add to camera container and look at it
      cameraContainerRef.current.addChild(newSpineInstance);
      cameraContainerRef.current.lookAtChild(newSpineInstance);
      
      // Analyze spine data
      const analysisData = SpineAnalyzer.analyze(newSpineInstance);
      setBenchmarkData(analysisData);
      
      setSpineInstance(newSpineInstance);
      addToast('Spine files loaded successfully', 'success');
    } catch (error) {
      console.error('Error loading Spine files:', error);
      addToast(`Error loading Spine files: ${error instanceof Error ? error.message : 'Unknown error'}`, 'error');
      throw error; // Re-throw to allow the calling code to handle it
    } finally {
      setIsLoading(false);
    }
  };

  return {
    spineInstance,
    loadSpineFiles,
    isLoading,
    benchmarkData,
  };
}
```


## src\index.tsx

```
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import { ToastProvider } from './hooks/ToastContext';
import './styles.css';
// Import the custom toastify styles
import './toastify.css'; // Make sure to create this file with the custom styles

// Create root element
const container = document.getElementById('root');
if (!container) {
  throw new Error('Failed to find the root element');
}

const root = createRoot(container);

// Render the app
root.render(
  <React.StrictMode>
    <ToastProvider>
      <App />
    </ToastProvider>
  </React.StrictMode>
);
```


## src\locales\en.json

```
{
  "error": {
    "1001": "File read error: {0}",
    "1002": "Image load error {0}: {1}",
    "1003": "JSON parse error for skeleton file {0}: {1}",
    "1004": "Unsupported Spine version: {0}. Maximum supported version: 4.1",
    "1005": "Incorrect structure in skeleton JSON file: {0}",
    "1006": "Error reading binary skeleton file: {0}",
    "1007": "Error reading atlas file: {0}",
    "1008": "Invalid atlas file structure: {0}",
    "1009": "Texture not found: {0}",
    "1010": "Error creating atlas: {0}",
    "1011": "Skeleton contains no bones",
    "1012": "Skeleton parse error: {0}",
    "1013": "Error creating Spine instance: {0}",
    "1014": "Critical error creating asset: {0}",
    "1015": "File processing error {0}: {1}",
    "1016": "Missing skeleton file (.json or .skel). Please upload the skeleton file along with the atlas.",
    "1017": "Missing atlas file (.atlas). Please upload it along with the skeleton."
  }
}
```


## src\locales\ru.json

```
{
    "error": {
      "1001": "Ошибка чтения файла: {0}",
      "1002": "Ошибка загрузки изображения {0}: {1}",
      "1003": "Ошибка парсинга JSON файла скелета {0}: {1}",
      "1004": "Неподдерживаемая версия Spine: {0}. Максимальная поддерживаемая версия: 4.1",
      "1005": "Некорректная структура JSON файла скелета: {0}",
      "1006": "Ошибка чтения бинарного файла скелета: {0}",
      "1007": "Ошибка чтения файла атласа: {0}",
      "1008": "Некорректная структура файла атласа: {0}",
      "1009": "Текстура не найдена: {0}",
      "1010": "Ошибка создания атласа: {0}",
      "1011": "Скелет не содержит костей",
      "1012": "Ошибка парсинга скелета: {0}",
      "1013": "Ошибка создания экземпляра Spine: {0}",
      "1014": "Критическая ошибка при создании ассета: {0}",
      "1015": "Произошла ошибка при обработке файла {0}: {1}",
      "1016": "Отсутствует файл скелета (.json или .skel). Загрузите файл скелета вместе с атласом.",
      "1017": "Отсутствует атлас файл (.atlas). Загрузите его вместе со скелетом."
    }
  }
```


## src\md-module.d.ts

```
/// <reference types="vite/client" />

declare module '*.md' {
    const attributes: Record<string, unknown>;
    const html: string;
    const raw: string;
    export { attributes, html, raw };
  }
```


## src\styles.css

```
:root {
  --color-dark: #282b30;
  --color-darker: #1a1a1a;
  --color-light: #f1f1f1;
  --color-accent: #5865f2;
  --color-success: #43b581;
  --color-warning: #faa61a;
  --color-error: #f04747;
  
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 16px;
  
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.12);
  --shadow-lg: 0 10px 20px rgba(0, 0, 0, 0.15), 0 3px 6px rgba(0, 0, 0, 0.1);
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  color: var(--color-light);
  background-color: var(--color-dark);
  min-height: 100vh;
  width: 100%;
  overflow: hidden;
}

/* App Container */
.app-container {
  position: relative;
  width: 100vw;
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Canvas Container */
.canvas-container {
  position: relative;
  width: 100%;
  flex: 1;
  overflow: hidden;
}

#pixiCanvas {
  display: block;
  width: 100%;
  height: 100%;
}

/* Controls container at the bottom */
.controls-container {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: 60px;
  padding: 0 16px;
  background-color: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(10px);
  z-index: 100;
}

.left-controls,
.right-controls {
  display: flex;
  gap: 8px;
}

.center-controls {
  flex-grow: 1;
  display: flex;
  justify-content: center;
}

/* Drop Area */
.drop-area {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: var(--radius-md);
  pointer-events: none;
  z-index: 10;
}

.drop-area p {
  font-size: 1.5rem;
  color: rgba(255, 255, 255, 0.8);
  text-align: center;
  max-width: 80%;
}

.drop-area.highlight {
  background-color: rgba(0, 0, 0, 0.3);
  border-color: var(--color-accent);
}

/* Loading Indicator */
.loading-indicator {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 20;
}

.loading-indicator p {
  font-size: 1.5rem;
  color: var(--color-light);
  background-color: rgba(0, 0, 0, 0.7);
  padding: 1rem 2rem;
  border-radius: var(--radius-md);
}

/* Icon Button */
.icon-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  background-color: transparent;
  border: none;
  border-radius: var(--radius-sm);
  color: var(--color-light);
  cursor: pointer;
  transition: background-color 0.2s ease, color 0.2s ease;
}

.icon-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.icon-button:active {
  background-color: rgba(255, 255, 255, 0.2);
}

.icon-button.active {
  background-color: var(--color-accent);
  color: white;
}

.icon-button.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.icon-button .icon {
  width: 20px;
  height: 20px;
}

/* Animation Controls */
.animation-controls {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 0 16px;
  height: 100%;
}

.animation-name {
  font-weight: 500;
  min-width: 120px;
  text-align: center;
  padding: 4px 8px;
  background-color: rgba(255, 255, 255, 0.1);
  border-radius: var(--radius-sm);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.playback-controls {
  display: flex;
  gap: 4px;
}

.animation-settings {
  display: flex;
  align-items: center;
  gap: 12px;
}

.loop-toggle {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
}

/* Animation Selector Dropdown Dark Styling */
.animation-selector {
  background-color: rgba(0, 0, 0, 0.3);
  color: var(--color-light);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: var(--radius-sm);
  padding: 6px 10px;
  appearance: none; /* Remove default styling */
  cursor: pointer;
  /* Add custom dropdown arrow */
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 8px center;
  padding-right: 28px; /* Space for the arrow */
}

/* Style the dropdown options */
.animation-selector option {
  background-color: #1a1a1a; /* Dark background for options */
  color: var(--color-light);
  padding: 8px 12px;
}

/* Firefox specific styling */
@-moz-document url-prefix() {
  .animation-selector {
    text-indent: 0.01px;
    text-overflow: '';
    padding-right: 28px; /* Space for the arrow */
  }
  
  .animation-selector:-moz-focusring {
    color: transparent;
    text-shadow: 0 0 0 var(--color-light);
  }
}

/* Hover and focus states */
.animation-selector:hover,
.animation-selector:focus {
  border-color: rgba(255, 255, 255, 0.2);
  outline: none;
}

/* For WebKit browsers (Chrome, Safari) */
.animation-selector::-webkit-scrollbar {
  width: 8px;
}

.animation-selector::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.2);
}

.animation-selector::-webkit-scrollbar-thumb {
  background-color: rgba(100, 100, 100, 0.4);
  border-radius: 4px;
}

/* Color Picker */
.color-picker-container {
  position: relative;
}

.color-picker-dropdown {
  position: absolute;
  bottom: 48px;
  right: 0;
  width: 220px;
  background-color: var(--color-darker);
  border-radius: var(--radius-md);
  padding: 12px;
  box-shadow: var(--shadow-md);
  z-index: 1000;
}

.color-picker-swatches {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
  margin-bottom: 12px;
}

.color-swatch {
  width: 32px;
  height: 32px;
  border-radius: var(--radius-sm);
  border: 2px solid transparent;
  cursor: pointer;
}

.color-swatch.active {
  border-color: var(--color-accent);
}

.color-picker-custom {
  display: flex;
  align-items: center;
  gap: 8px;
}

.color-picker-custom input[type="color"] {
  width: 32px;
  height: 32px;
  border: none;
  background: none;
  cursor: pointer;
}

.color-picker-custom input[type="text"] {
  flex-grow: 1;
  background-color: rgba(0, 0, 0, 0.3);
  color: var(--color-light);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: var(--radius-sm);
  padding: 4px 8px;
}

/* Info Panel */
.info-panel-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 2000;
}

.info-panel {
  width: 80%;
  max-width: 1000px;
  height: 80%;
  background-color: var(--color-darker);
  border-radius: var(--radius-lg);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  box-shadow: var(--shadow-lg);
}

.info-panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.info-panel-tabs {
  display: flex;
  overflow-x: auto;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.tab-button {
  padding: 12px 16px;
  background-color: transparent;
  border: none;
  color: var(--color-light);
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.2s ease;
  white-space: nowrap;
}

.tab-button:hover {
  background-color: rgba(255, 255, 255, 0.05);
}

.tab-button.active {
  background-color: rgba(255, 255, 255, 0.1);
  border-bottom: 2px solid var(--color-accent);
}

.info-panel-content {
  flex-grow: 1;
  overflow-y: auto;
  padding: 16px;
}

/* Benchmark content */
.tab-content {
  padding: 16px;
}

.tab-content h3 {
  margin-bottom: 16px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  padding-bottom: 8px;
}

/* Improve table headers for better readability */
.benchmark-table thead {
  position: sticky;
  top: 0;
  z-index: 10;
}

.benchmark-table th {
  background-color: rgba(20, 22, 26, 0.95); /* Dark background with opacity */
  padding: 10px 8px;
  text-align: left;
  font-weight: 600;
  color: #ffffff;
  border-bottom: 2px solid rgba(255, 255, 255, 0.1);
  position: sticky;
  top: 0;
  backdrop-filter: blur(2px); /* Add blur effect for better readability */
  white-space: nowrap; /* Prevent text wrapping */
}

/* Add a subtle shadow to make headers stand out more */
.benchmark-table thead::after {
  content: '';
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  height: 4px;
  background: linear-gradient(to bottom, rgba(0, 0, 0, 0.1), transparent);
  pointer-events: none;
}

/* Improve table cell styling */
.benchmark-table td {
  padding: 8px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  vertical-align: middle;
}

/* Ensure proper table container height */
.tab-content .benchmark-table-container {
  max-height: calc(100vh - 240px);
  overflow-y: auto;
}

/* Add hover effect on table rows for better readability */
.benchmark-table tbody tr:hover td {
  background-color: rgba(255, 255, 255, 0.05);
}

/* Make sure table fills available width */
.benchmark-table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
}

/* Add specific styles for the Mesh Analysis table */
#meshTableContainer .benchmark-table th,
[data-tab="meshAnalysis"] .benchmark-table th {
  background-color: rgba(20, 22, 26, 0.95);
  color: #ffffff;
  padding: 10px 8px;
}

.row-warning {
  background-color: rgba(250, 166, 26, 0.1);
}

.row-danger {
  background-color: rgba(240, 71, 71, 0.1);
}

.analysis-notes {
  margin-top: 24px;
  padding: 16px;
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: var(--radius-md);
}

.analysis-notes h4 {
  margin-bottom: 8px;
}

.analysis-notes ul {
  padding-left: 16px;
}

.analysis-notes li {
  margin-bottom: 4px;
}

/* Skeleton Tree */
.skeleton-tree {
  list-style: none;
  padding-left: 0;
}

.tree-node {
  margin: 5px 0;
  position: relative;
}

.tree-node .node-label {
  cursor: pointer;
  padding: 2px 5px;
  border-radius: 3px;
}

.tree-node .node-label:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.tree-node ul {
  padding-left: 20px;
  margin: 5px 0;
}

/* Summary */
.benchmark-summary {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.score-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 16px 0;
}

.performance-score {
  font-size: 4rem;
  font-weight: bold;
}

.score-label {
  font-size: 1rem;
  opacity: 0.7;
}

.skeleton-stats {
  margin-top: 16px;
}

.stats-table {
  width: 100%;
  max-width: 400px;
  margin: 16px 0;
}

.stats-table td {
  padding: 8px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.stats-table td:first-child {
  font-weight: 500;
}

.performance-concerns,
.optimization-tips {
  margin-top: 16px;
  padding: 16px;
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: var(--radius-md);
}

/* Toast */
.toast-wrapper {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: column-reverse;
  gap: 12px;
  z-index: 3000;
}

.toast {
  padding: 12px 16px;
  border-radius: var(--radius-md);
  background-color: var(--color-darker);
  box-shadow: var(--shadow-md);
  min-width: 300px;
  max-width: 400px;
  animation: slide-up 0.3s ease;
  cursor: pointer;
}

.toast p {
  margin: 0;
}

.toast-info {
  border-left: 4px solid var(--color-accent);
}

.toast-success {
  border-left: 4px solid var(--color-success);
}

.toast-warning {
  border-left: 4px solid var(--color-warning);
}

.toast-error {
  border-left: 4px solid var(--color-error);
}

@keyframes slide-up {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .animation-controls {
    flex-direction: column;
    padding: 8px;
    gap: 8px;
  }
  
  .controls-container {
    height: auto;
    padding: 8px;
    flex-wrap: wrap;
  }
  
  .info-panel {
    width: 95%;
    height: 95%;
  }
  
  .color-picker-dropdown {
    right: -80px;
  }
}
```


## src\text\about.md

```
В инструменте представлена документация с требованиями и дроп зона анализа файлов.
Под капотом pixi v7.4 и spine рантайм v4.1, в них внедрены изменения для подсчета нагрузки на рендер.

```


## src\text\batch.md

```
- PIXI.AbstractBatchRenderer накапливает пул BatchDrawCall и flush-ит их, наличие большого количества режимов наложения и мешей на одном спайне может вынудить делать отдельный дроу-колл чтоб отрисовать все нужное для кадра
```


## src\text\blend.md

```
- Blend Mode вызывают дополнительные flush-ы шейдеров при рендере и создают высокую нагрузку
- Использование Add и Mul режимов лучше минимизировать или сводить на ноль для снижения температурной нагрузки
- Нужно использовать не более двух аттачментов с аддитивным режимом на анимацию
- Режимы наложения можно использовать только в анонсерах и специальных символах (скаттер, вайлд)
- Текстурный атлас снижает число переключений текстур в рендере, однако бленды делают ровно противоположное
```


## src\text\bones.md

```
- Меньше костей - лучше
- Меньше глубина дерева - лучше
- Наследование положение от родителя дешево
- Иметь вторую рут кость для "рут моушена" скелета нормально, однако иерархия отрицательно влияет на производительность

```


## src\text\bounds.md

```
- Границы передвигающихся по экрану объектов важно вручную "ограничить" чтобы pixi понял когда можно прекратить рендер
```


## src\text\clipping.md

```
- Клиппинг - это самая дорогая операция всех спайн рантаймов, особенно если есть меш, и тем более с большим числом вертексов
- Если без клиппинга не обойтись, делайте клиппинг аттачмент с тремя вершинами
- Если вершин надо больше, старайтесь делать маску выпуклым многоугольником
- Дешевле добавить маску в движке, она будет вызывать один стенсил шейдер
```


## src\text\general.md

```
---
title: Awesome Title
description: Describe this awesome content
tags:
  - "great"
  - "awesome"
  - "rad"
---

Игра работает в 60 fps, учитывайте это при создании анимаций. Каждый кадр будет находиться на экране ~16.66мс.

Скелеты называем в snake_case, например, blue_fish, huge_win.

События Spine позволяют фронтенду проиграть звуки или запустить какой-то сегмент кода. События должны иметь названия в camelCase и начинаться с on , например, onBeforeReelStop или onWin. 

Стараемся избегать float значений в событиях, так как возможно ситуации с неверным округлением числа. Если использование необходимо, ограничиваемся тремя знаками после запятой.
Можно использовать папки анимаций, названия тоже в snake_case.

Анимации могут иметь любую длину. При одновременном запуске анимаций в разных объектах возможен рассинхрон в 1-2 кадра, игрок это не заметит, но не пытайтесь делать идеальную синхронизацию.

Для одного отображаемого на экране объекта (например, символа) используем один скелет. Если нужны независимые эффекты, которые должны воспроизвестись прямо под/над этим объектом, анимацию которых невозможно по какой-то причине воспроизвести одновременно с основной idle или выигрышной, то необходимо убрать их в отдельную кость скелета. Данные эффекты будут проиграны параллельно на другом треке в необходимый момент. В коде это сделать проще, чем несколько отдельных Spine объектов.

Мы можем проигрывать параллельно любое количество анимаций на одном скелете. Если эти анимации модифицируют одинаковые ключи, возможны конфликты анимаций (что-то будет дёргаться). Поэтому, например, можно раздельно анимировать тело и руки персонажа для упрощения параллельного воспроизведения. Mesh-трансформации spine нельзя запускать параллельно, так как вся деформация меша описывается одним ключём.
```


## src\text\hiding.md

```
- Снижение размера или альфы аттачмента в ноль - плохой способ скрывать аттачмент
- *Аттачмент надо скрывать таймлайном*
```


## src\text\mesh.md

```
- Mesh Link снижает потребление памяти, при вычислении положения меша переиспользуются вычисленные ранее в скелете значения однако на нагрузку CPU это сильно не влияет
- Деформационные ключи нагружают CPU базовыми операциями умножения для каждого вертекса, то есть чем больше костей влияют на меш и чем больше в нем вертекс, тем больше нагрузка. Один вес и 10 вертексов это примерно то же самое, что три веса и три вертекса. По этой причине лица и другие меши с большим числом вертексов лучше вешать на меньшее количество костей.
- Деформационные ключи едят много RAM, использование большого количество ключей деформации может увеличить размер скелета
- Для снижения нагрузки на RAM лучше использовать деформационные ключи реже или отказываться от них
- Лишние ключи деформации меша полезно чистить функциями Prune и Smooth
```


## src\text\names.md

```
- Кости должны именоваться латиницей
- Все слова пишутся маленькими буквами и соединяются символом нижнего подчеркивания (_)
- Примеры snake_case: **moustache_holder**, **frame_fx_holder**, **frame_fx_2**
- Не используются дефисы или другие специальные символы
- Для разграничения левых/правых костей разрешено использование суффиксов **_L** и **_R**: **pupil_L**, **pupil_R**

```


## src\text\particles.md

```
- Spine предназначен для скелетной анимации, а не для частиц - их нужно делать средствами движка или секвенциями
- Анимация частиц в Spine - это больная нагрузка на CPU и RAM
- Pixi имеет пакет particle-emitter для частиц и редактор частиц (ссылка внизу страницы)
```


## src\text\path.md

```
- Path Constraint потребляют много CPU если вдоль них следует большое количество костей, однако это редко будет ботлнеком
- Path и IK Constraint являются важными инструментами, управление над котороми можно вести из кода
```


## src\text\placeholder.md

```
- Для замены слотов на разные игровые сущности в рантайме используются placeholder слоты
- В слот необходимо положить маленькую картинку, например 2x2 белый квадрат с 1% прозрачности (в картинке)
- В гайде необходимо описать разработчику какая сущность будет подставляться в этот слот
```


## src\text\timelines.md

```
- Таймлайны и число ключей в них оказывают RAM нагрузку и раздувают размер файла, однако на CPU влияют минимально
- Снижение числа таймлайнов рекомендованно только для организации анимаций
- Мусор из таймлайнов можно убрать функцией Clean Up спайна
```


## src\toastify.css

```
/* Custom styling for React Toastify to match app theme */
.Toastify__toast {
    border-radius: var(--radius-md);
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 1px 3px rgba(0, 0, 0, 0.2);
  }
  
  .Toastify__toast--dark {
    background-color: #1a1a1a;
    border-left: 4px solid rgba(255, 255, 255, 0.2);
  }
  
  .Toastify__toast--info.Toastify__toast--dark {
    border-left-color: var(--color-accent, #5865f2);
  }
  
  .Toastify__toast--success.Toastify__toast--dark {
    border-left-color: var(--color-success, #43b581);
  }
  
  .Toastify__toast--warning.Toastify__toast--dark {
    border-left-color: var(--color-warning, #faa61a);
  }
  
  .Toastify__toast--error.Toastify__toast--dark {
    border-left-color: var(--color-error, #f04747);
  }
  
  .Toastify__progress-bar--dark {
    background: linear-gradient(
      to right,
      rgba(255, 255, 255, 0.7),
      rgba(255, 255, 255, 0.2)
    );
  }
  
  .Toastify__close-button--dark {
    color: rgba(255, 255, 255, 0.5);
    opacity: 0.7;
  }
  
  .Toastify__close-button--dark:hover, 
  .Toastify__close-button--dark:focus {
    opacity: 1;
  }
  
  /* Make toasts responsive on mobile */
  @media only screen and (max-width: 480px) {
    .Toastify__toast-container {
      width: 100%;
      padding: 0;
      left: 0;
      margin: 0;
    }
    
    .Toastify__toast-container--bottom-center {
      bottom: 0;
      transform: translateX(-50%);
    }
    
    .Toastify__toast {
      margin-bottom: 0;
      border-radius: 0;
    }
  }
```


## src\utils\fileUtils.ts

```
/**
 * Utility functions for handling file trees and folder drops
 */

// Interface for FileSystemEntry (needed for TypeScript support)
interface FileSystemEntry {
  isFile: boolean;
  isDirectory: boolean;
  name: string;
  fullPath?: string;
  file(callback: (file: File) => void, errorCallback?: (error: any) => void): void;
  createReader(): FileSystemDirectoryReader;
}

interface FileSystemDirectoryReader {
  readEntries(callback: (entries: FileSystemEntry[]) => void, errorCallback?: (error: any) => void): void;
}

// Extending DataTransferItem to include webkitGetAsEntry
//@ts-ignore
interface ExtendedDataTransferItem extends DataTransferItem {
  webkitGetAsEntry(): FileSystemEntry | null;
}

/**
 * Recursively traverses a file tree and collects all files
 */
export const traverseFileTree = async (
  item: FileSystemEntry, 
  path: string = '',
  fileList: File[] = []
): Promise<File[]> => {
  if (item.isFile) {
    // Get file and add to file list
    const file = await new Promise<File>((resolve, reject) => {
      item.file((file) => {
        resolve(file);
      }, (error) => {
        reject(error);
      });
    });
    
    // Create a new file with the correct path to preserve folder structure
    const fullPath = path + file.name;
    const fileWithPath = new File(
      [file], 
      fullPath, 
      { type: file.type }
    );
    
    // Store the original relative path for later use
    Object.defineProperty(fileWithPath, 'webkitRelativePath', {
      writable: false,
      value: fullPath
    });
    
    fileList.push(fileWithPath);
    return fileList;
  } else if (item.isDirectory) {
    // Get folder contents
    const entries = await new Promise<FileSystemEntry[]>((resolve, reject) => {
      const dirReader = item.createReader();
      const allEntries: FileSystemEntry[] = [];
      
      // Directory readers can only read a certain number of entries at a time
      // We need to keep calling readEntries until it returns an empty array
      const readEntries = () => {
        dirReader.readEntries((entries) => {
          if (entries.length) {
            allEntries.push(...entries);
            readEntries(); // Continue reading if there are more entries
          } else {
            resolve(allEntries); // No more entries, we're done
          }
        }, (error) => {
          reject(error);
        });
      };
      
      readEntries();
    });
    
    // Process all directory entries recursively
    for (const entry of entries) {
      await traverseFileTree(entry, path + item.name + '/', fileList);
    }
    
    return fileList;
  }
  
  return fileList;
};

/**
 * Handle drop event and collect all files from the dropped items
 */
export const handleDroppedItems = async (items: DataTransferItemList): Promise<File[]> => {
  console.log('Processing dropped items:', items.length);
  console.log(items[0],items[1],items[2])
  const allFiles: File[] = [];
  
  // First try to handle as directory drops via webkitGetAsEntry
  if (items[0] && 'webkitGetAsEntry' in items[0]) {
    for (let i = 0; i < items.length; i++) {
      const item = items[i] as ExtendedDataTransferItem;
      const entry = item.webkitGetAsEntry();
      
      if (entry) {
        const files = await traverseFileTree(entry);
        allFiles.push(...files);
      }
    }
  } else {
    // Fallback for browsers that don't support webkitGetAsEntry
    console.log('Fallback: webkitGetAsEntry not supported');
  }
  
  // If no files were found through the directory API, try to get files directly
  if (allFiles.length === 0) {
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (item.kind === 'file') {
        const file = item.getAsFile();
        if (file) {
          allFiles.push(file);
        }
      }
    }
  }
  
  console.log('Total files collected:', allFiles.length);
  console.log('File names:', allFiles.map(f => f.name));
  
  return allFiles;
};

/**
 * Converts an array of Files to a FileList-like object
 */
export const filesToFileList = (files: File[]): FileList => {
  const dataTransfer = new DataTransfer();
  files.forEach(file => dataTransfer.items.add(file));
  return dataTransfer.files;
};
```


## src\utils\mergeMaps.ts

```
export function mergeMaps(propNames: string[], ...maps: Map<string, any>[]) {
  const mergedMap = new Map<string, Record<string, any>>();

  // Ensure we have enough property names for all maps
  if (propNames.length < maps.length) {
    throw new Error("Not enough property names provided for all maps");
  }

  // Get all unique keys from all maps
  const allKeys = new Set(maps.flatMap((map) => [...map.keys()]));

  allKeys.forEach((key) => {
    const mergedValue: Record<string, any> = {};

    maps.forEach((map, index) => {
      const propName = propNames[index];
      mergedValue[propName] = map.get(key) ?? "";
    });

    mergedMap.set(key, mergedValue);
  });

  return mergedMap;
}

```


## src\utils\toast.ts

```
export function toast(message: string, duration = 4000) {
  const toast = document.createElement("div");
  toast.className = "toast";
  toast.textContent = message;

  toast.addEventListener("click", () => {
      hideToast(toast);
  });

  // Find or create the toast container
  let container = document.getElementById("toast-container");
  if (!container) {
      container = document.createElement("div");
      container.id = "toast-container";
      document.body.appendChild(container);
  }

  // Append the toast to the container
  container.appendChild(toast);

  setTimeout(() => {
      hideToast(toast);
  }, duration);
}

function hideToast(toast: HTMLElement) {
  toast.classList.add("hide");
  setTimeout(() => {
      toast?.parentElement?.removeChild(toast);
  }, 500);
}
```


## src\vite.env.d.ts

```
/// <reference types="vite/client" />

declare module '*.md' {
    const attributes: Record<string, unknown>;
    const html: string;
    const raw: string;
    export { attributes, html, raw };
  }
```


## src\webgl-memory.js

```
/* webgl-memory@1.1.1, license MIT */
(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
})((function () { 'use strict';

  /* PixelFormat */
  const ALPHA                          = 0x1906;
  const RGB                            = 0x1907;
  const RGBA                           = 0x1908;
  const LUMINANCE                      = 0x1909;
  const LUMINANCE_ALPHA                = 0x190A;
  const DEPTH_COMPONENT                = 0x1902;
  const DEPTH_STENCIL                  = 0x84F9;

  const R8                           = 0x8229;
  const R8_SNORM                     = 0x8F94;
  const R16F                         = 0x822D;
  const R32F                         = 0x822E;
  const R8UI                         = 0x8232;
  const R8I                          = 0x8231;
  const RG16UI                       = 0x823A;
  const RG16I                        = 0x8239;
  const RG32UI                       = 0x823C;
  const RG32I                        = 0x823B;
  const RG8                          = 0x822B;
  const RG8_SNORM                    = 0x8F95;
  const RG16F                        = 0x822F;
  const RG32F                        = 0x8230;
  const RG8UI                        = 0x8238;
  const RG8I                         = 0x8237;
  const R16UI                        = 0x8234;
  const R16I                         = 0x8233;
  const R32UI                        = 0x8236;
  const R32I                         = 0x8235;
  const RGB8                         = 0x8051;
  const SRGB8                        = 0x8C41;
  const RGB565                       = 0x8D62;
  const RGB8_SNORM                   = 0x8F96;
  const R11F_G11F_B10F               = 0x8C3A;
  const RGB9_E5                      = 0x8C3D;
  const RGB16F                       = 0x881B;
  const RGB32F                       = 0x8815;
  const RGB8UI                       = 0x8D7D;
  const RGB8I                        = 0x8D8F;
  const RGB16UI                      = 0x8D77;
  const RGB16I                       = 0x8D89;
  const RGB32UI                      = 0x8D71;
  const RGB32I                       = 0x8D83;
  const RGBA8                        = 0x8058;
  const SRGB8_ALPHA8                 = 0x8C43;
  const RGBA8_SNORM                  = 0x8F97;
  const RGB5_A1                      = 0x8057;
  const RGBA4                        = 0x8056;
  const RGB10_A2                     = 0x8059;
  const RGBA16F                      = 0x881A;
  const RGBA32F                      = 0x8814;
  const RGBA8UI                      = 0x8D7C;
  const RGBA8I                       = 0x8D8E;
  const RGB10_A2UI                   = 0x906F;
  const RGBA16UI                     = 0x8D76;
  const RGBA16I                      = 0x8D88;
  const RGBA32I                      = 0x8D82;
  const RGBA32UI                     = 0x8D70;

  const DEPTH_COMPONENT16            = 0x81A5;
  const DEPTH_COMPONENT24            = 0x81A6;
  const DEPTH_COMPONENT32F           = 0x8CAC;
  const DEPTH32F_STENCIL8            = 0x8CAD;
  const DEPTH24_STENCIL8             = 0x88F0;

  /* DataType */
  // const BYTE                         = 0x1400;
  const UNSIGNED_BYTE                = 0x1401;
  // const SHORT                        = 0x1402;
  const UNSIGNED_SHORT               = 0x1403;
  // const INT                          = 0x1404;
  const UNSIGNED_INT                 = 0x1405;
  const FLOAT                        = 0x1406;
  const UNSIGNED_SHORT_4_4_4_4       = 0x8033;
  const UNSIGNED_SHORT_5_5_5_1       = 0x8034;
  const UNSIGNED_SHORT_5_6_5         = 0x8363;
  const HALF_FLOAT                   = 0x140B;
  const HALF_FLOAT_OES               = 0x8D61;  // Thanks Khronos for making this different >:(

  const SRGB_ALPHA_EXT               = 0x8C42;

  /**
   * @typedef {Object} TextureFormatDetails
   * @property {number} textureFormat format to pass texImage2D and similar functions.
   * @property {boolean} colorRenderable true if you can render to this format of texture.
   * @property {boolean} textureFilterable true if you can filter the texture, false if you can ony use `NEAREST`.
   * @property {number[]} type Array of possible types you can pass to texImage2D and similar function
   * @property {Object.<number,number>} bytesPerElementMap A map of types to bytes per element
   * @private
   */

  let s_textureInternalFormatInfo;
  function getTextureInternalFormatInfo(internalFormat) {
    if (!s_textureInternalFormatInfo) {
      // NOTE: these properties need unique names so we can let Uglify mangle the name.
      const t = {};
      // unsized formats
      t[ALPHA]              = { bytesPerElement: [1, 2, 2, 4],        type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT], };
      t[LUMINANCE]          = { bytesPerElement: [1, 2, 2, 4],        type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT], };
      t[LUMINANCE_ALPHA]    = { bytesPerElement: [2, 4, 4, 8],        type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT], };
      t[RGB]                = { bytesPerElement: [3, 6, 6, 12, 2],    type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_5_6_5], };
      t[RGBA]               = { bytesPerElement: [4, 8, 8, 16, 2, 2], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1], };
      t[SRGB_ALPHA_EXT]     = { bytesPerElement: [4, 8, 8, 16, 2, 2], type: [UNSIGNED_BYTE, HALF_FLOAT, HALF_FLOAT_OES, FLOAT, UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1], };
      t[DEPTH_COMPONENT]    = { bytesPerElement: [2, 4],              type: [UNSIGNED_INT, UNSIGNED_SHORT], };
      t[DEPTH_STENCIL]      = { bytesPerElement: [4],                 };

      // sized formats
      t[R8]                 = { bytesPerElement: [1],  };
      t[R8_SNORM]           = { bytesPerElement: [1],  };
      t[R16F]               = { bytesPerElement: [2],  };
      t[R32F]               = { bytesPerElement: [4],  };
      t[R8UI]               = { bytesPerElement: [1],  };
      t[R8I]                = { bytesPerElement: [1],  };
      t[R16UI]              = { bytesPerElement: [2],  };
      t[R16I]               = { bytesPerElement: [2],  };
      t[R32UI]              = { bytesPerElement: [4],  };
      t[R32I]               = { bytesPerElement: [4],  };
      t[RG8]                = { bytesPerElement: [2],  };
      t[RG8_SNORM]          = { bytesPerElement: [2],  };
      t[RG16F]              = { bytesPerElement: [4],  };
      t[RG32F]              = { bytesPerElement: [8],  };
      t[RG8UI]              = { bytesPerElement: [2],  };
      t[RG8I]               = { bytesPerElement: [2],  };
      t[RG16UI]             = { bytesPerElement: [4],  };
      t[RG16I]              = { bytesPerElement: [4],  };
      t[RG32UI]             = { bytesPerElement: [8],  };
      t[RG32I]              = { bytesPerElement: [8],  };
      t[RGB8]               = { bytesPerElement: [3],  };
      t[SRGB8]              = { bytesPerElement: [3],  };
      t[RGB565]             = { bytesPerElement: [2],  };
      t[RGB8_SNORM]         = { bytesPerElement: [3],  };
      t[R11F_G11F_B10F]     = { bytesPerElement: [4],  };
      t[RGB9_E5]            = { bytesPerElement: [4],  };
      t[RGB16F]             = { bytesPerElement: [6],  };
      t[RGB32F]             = { bytesPerElement: [12], };
      t[RGB8UI]             = { bytesPerElement: [3],  };
      t[RGB8I]              = { bytesPerElement: [3],  };
      t[RGB16UI]            = { bytesPerElement: [6],  };
      t[RGB16I]             = { bytesPerElement: [6],  };
      t[RGB32UI]            = { bytesPerElement: [12], };
      t[RGB32I]             = { bytesPerElement: [12], };
      t[RGBA8]              = { bytesPerElement: [4],  };
      t[SRGB8_ALPHA8]       = { bytesPerElement: [4],  };
      t[RGBA8_SNORM]        = { bytesPerElement: [4],  };
      t[RGB5_A1]            = { bytesPerElement: [2],  };
      t[RGBA4]              = { bytesPerElement: [2],  };
      t[RGB10_A2]           = { bytesPerElement: [4],  };
      t[RGBA16F]            = { bytesPerElement: [8],  };
      t[RGBA32F]            = { bytesPerElement: [16], };
      t[RGBA8UI]            = { bytesPerElement: [4],  };
      t[RGBA8I]             = { bytesPerElement: [4],  };
      t[RGB10_A2UI]         = { bytesPerElement: [4],  };
      t[RGBA16UI]           = { bytesPerElement: [8],  };
      t[RGBA16I]            = { bytesPerElement: [8],  };
      t[RGBA32I]            = { bytesPerElement: [16], };
      t[RGBA32UI]           = { bytesPerElement: [16], };
      // Sized Internal
      t[DEPTH_COMPONENT16]  = { bytesPerElement: [2],  };
      t[DEPTH_COMPONENT24]  = { bytesPerElement: [4],  };
      t[DEPTH_COMPONENT32F] = { bytesPerElement: [4],  };
      t[DEPTH24_STENCIL8]   = { bytesPerElement: [4],  };
      t[DEPTH32F_STENCIL8]  = { bytesPerElement: [4],  };

      s_textureInternalFormatInfo = t;
    }
    return s_textureInternalFormatInfo[internalFormat];
  }

  function makeComputeBlockRectSizeFunction(blockWidth, blockHeight, bytesPerBlock) {
    return function(width, height, depth) {
      const blocksAcross = (width + blockWidth - 1) / blockWidth | 0;
      const blocksDown =  (height + blockHeight - 1) / blockHeight | 0;
      return blocksAcross * blocksDown * bytesPerBlock * depth;
    };
  }

  function makeComputePaddedRectSizeFunction(minWidth, minHeight, divisor) {
    return function(width, height, depth) {
      return (Math.max(width, minWidth) * Math.max(height, minHeight) / divisor | 0) * depth;
    };
  }

  // WEBGL_compressed_texture_s3tc
  const COMPRESSED_RGB_S3TC_DXT1_EXT        = 0x83F0;
  const COMPRESSED_RGBA_S3TC_DXT1_EXT       = 0x83F1;
  const COMPRESSED_RGBA_S3TC_DXT3_EXT       = 0x83F2;
  const COMPRESSED_RGBA_S3TC_DXT5_EXT       = 0x83F3;
  // WEBGL_compressed_texture_etc1
  const COMPRESSED_RGB_ETC1_WEBGL           = 0x8D64;
  // WEBGL_compressed_texture_pvrtc
  const COMPRESSED_RGB_PVRTC_4BPPV1_IMG      = 0x8C00;
  const COMPRESSED_RGB_PVRTC_2BPPV1_IMG      = 0x8C01;
  const COMPRESSED_RGBA_PVRTC_4BPPV1_IMG     = 0x8C02;
  const COMPRESSED_RGBA_PVRTC_2BPPV1_IMG     = 0x8C03;
  // WEBGL_compressed_texture_etc
  const COMPRESSED_R11_EAC                        = 0x9270;
  const COMPRESSED_SIGNED_R11_EAC                 = 0x9271;
  const COMPRESSED_RG11_EAC                       = 0x9272;
  const COMPRESSED_SIGNED_RG11_EAC                = 0x9273;
  const COMPRESSED_RGB8_ETC2                      = 0x9274;
  const COMPRESSED_SRGB8_ETC2                     = 0x9275;
  const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2  = 0x9276;
  const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277;
  const COMPRESSED_RGBA8_ETC2_EAC                 = 0x9278;
  const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC          = 0x9279;
  // WEBGL_compressed_texture_astc
  const COMPRESSED_RGBA_ASTC_4x4_KHR = 0x93B0;
  const COMPRESSED_RGBA_ASTC_5x4_KHR = 0x93B1;
  const COMPRESSED_RGBA_ASTC_5x5_KHR = 0x93B2;
  const COMPRESSED_RGBA_ASTC_6x5_KHR = 0x93B3;
  const COMPRESSED_RGBA_ASTC_6x6_KHR = 0x93B4;
  const COMPRESSED_RGBA_ASTC_8x5_KHR = 0x93B5;
  const COMPRESSED_RGBA_ASTC_8x6_KHR = 0x93B6;
  const COMPRESSED_RGBA_ASTC_8x8_KHR = 0x93B7;
  const COMPRESSED_RGBA_ASTC_10x5_KHR = 0x93B8;
  const COMPRESSED_RGBA_ASTC_10x6_KHR = 0x93B9;
  const COMPRESSED_RGBA_ASTC_10x8_KHR = 0x93BA;
  const COMPRESSED_RGBA_ASTC_10x10_KHR = 0x93BB;
  const COMPRESSED_RGBA_ASTC_12x10_KHR = 0x93BC;
  const COMPRESSED_RGBA_ASTC_12x12_KHR = 0x93BD;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 0x93D0;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 0x93D1;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 0x93D2;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 0x93D3;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 0x93D4;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 0x93D5;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 0x93D6;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 0x93D7;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 0x93D8;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 0x93D9;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 0x93DA;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 0x93DB;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 0x93DC;
  const COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 0x93DD;
  // WEBGL_compressed_texture_s3tc_srgb
  const COMPRESSED_SRGB_S3TC_DXT1_EXT        = 0x8C4C;
  const COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT  = 0x8C4D;
  const COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT  = 0x8C4E;
  const COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT  = 0x8C4F;
  // EXT_texture_compression_bptc
  const COMPRESSED_RGBA_BPTC_UNORM_EXT = 0x8E8C;
  const COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 0x8E8D;
  const COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 0x8E8E;
  const COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 0x8E8F;
  // EXT_texture_compression_rgtc
  const COMPRESSED_RED_RGTC1_EXT = 0x8DBB;
  const COMPRESSED_SIGNED_RED_RGTC1_EXT = 0x8DBC;
  const COMPRESSED_RED_GREEN_RGTC2_EXT = 0x8DBD;
  const COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 0x8DBE;

  const compressedTextureFunctions = new Map([
    [ COMPRESSED_RGB_S3TC_DXT1_EXT, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_RGBA_S3TC_DXT1_EXT, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_RGBA_S3TC_DXT3_EXT, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_RGBA_S3TC_DXT5_EXT, makeComputeBlockRectSizeFunction(4, 4, 16) ],

    [ COMPRESSED_RGB_ETC1_WEBGL, makeComputeBlockRectSizeFunction(4, 4, 8) ],

    [ COMPRESSED_RGB_PVRTC_4BPPV1_IMG, makeComputePaddedRectSizeFunction(8, 8, 2) ],
    [ COMPRESSED_RGBA_PVRTC_4BPPV1_IMG, makeComputePaddedRectSizeFunction(8, 8, 2) ],
    [ COMPRESSED_RGB_PVRTC_2BPPV1_IMG, makeComputePaddedRectSizeFunction(16, 8, 4) ],
    [ COMPRESSED_RGBA_PVRTC_2BPPV1_IMG, makeComputePaddedRectSizeFunction(16, 8, 4) ],

    [ COMPRESSED_R11_EAC, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SIGNED_R11_EAC, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_RGB8_ETC2, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SRGB8_ETC2, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, makeComputeBlockRectSizeFunction(4, 4, 8) ],

    [ COMPRESSED_RG11_EAC, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_SIGNED_RG11_EAC, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_RGBA8_ETC2_EAC, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, makeComputeBlockRectSizeFunction(4, 4, 16) ],

    [ COMPRESSED_RGBA_ASTC_4x4_KHR, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_RGBA_ASTC_5x4_KHR, makeComputeBlockRectSizeFunction(5, 4, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR, makeComputeBlockRectSizeFunction(5, 4, 16) ],
    [ COMPRESSED_RGBA_ASTC_5x5_KHR, makeComputeBlockRectSizeFunction(5, 5, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR, makeComputeBlockRectSizeFunction(5, 5, 16) ],
    [ COMPRESSED_RGBA_ASTC_6x5_KHR, makeComputeBlockRectSizeFunction(6, 5, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR, makeComputeBlockRectSizeFunction(6, 5, 16) ],
    [ COMPRESSED_RGBA_ASTC_6x6_KHR, makeComputeBlockRectSizeFunction(6, 6, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR, makeComputeBlockRectSizeFunction(6, 6, 16) ],
    [ COMPRESSED_RGBA_ASTC_8x5_KHR, makeComputeBlockRectSizeFunction(8, 5, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR, makeComputeBlockRectSizeFunction(8, 5, 16) ],
    [ COMPRESSED_RGBA_ASTC_8x6_KHR, makeComputeBlockRectSizeFunction(8, 6, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR, makeComputeBlockRectSizeFunction(8, 6, 16) ],
    [ COMPRESSED_RGBA_ASTC_8x8_KHR, makeComputeBlockRectSizeFunction(8, 8, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR, makeComputeBlockRectSizeFunction(8, 8, 16) ],
    [ COMPRESSED_RGBA_ASTC_10x5_KHR, makeComputeBlockRectSizeFunction(10, 5, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR, makeComputeBlockRectSizeFunction(10, 5, 16) ],
    [ COMPRESSED_RGBA_ASTC_10x6_KHR, makeComputeBlockRectSizeFunction(10, 6, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR, makeComputeBlockRectSizeFunction(10, 6, 16) ],
    [ COMPRESSED_RGBA_ASTC_10x8_KHR, makeComputeBlockRectSizeFunction(10, 8, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR, makeComputeBlockRectSizeFunction(10, 8, 16) ],
    [ COMPRESSED_RGBA_ASTC_10x10_KHR, makeComputeBlockRectSizeFunction(10, 10, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR, makeComputeBlockRectSizeFunction(10, 10, 16) ],
    [ COMPRESSED_RGBA_ASTC_12x10_KHR, makeComputeBlockRectSizeFunction(12, 10, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR, makeComputeBlockRectSizeFunction(12, 10, 16) ],
    [ COMPRESSED_RGBA_ASTC_12x12_KHR, makeComputeBlockRectSizeFunction(12, 12, 16) ],
    [ COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR, makeComputeBlockRectSizeFunction(12, 12, 16) ],

    [ COMPRESSED_SRGB_S3TC_DXT1_EXT, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, makeComputeBlockRectSizeFunction(4, 4, 8) ],
    [ COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, makeComputeBlockRectSizeFunction(4, 4, 16) ],
    [ COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, makeComputeBlockRectSizeFunction(4, 4, 16) ],

    [ COMPRESSED_RGBA_BPTC_UNORM_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
    [ COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
    [ COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
    [ COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],

    [ COMPRESSED_RED_RGTC1_EXT, makeComputeBlockRectSizeFunction( 4, 4, 8 ) ],
    [ COMPRESSED_SIGNED_RED_RGTC1_EXT, makeComputeBlockRectSizeFunction( 4, 4, 8 ) ],
    [ COMPRESSED_RED_GREEN_RGTC2_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
    [ COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT, makeComputeBlockRectSizeFunction( 4, 4, 16 ) ],
  ]);

  /**
   * Gets the number of bytes per element for a given internalFormat / type
   * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
   * @param {number} type The type parameter for texImage2D etc..
   * @return {number} the number of bytes per element for the given internalFormat, type combo
   * @memberOf module:twgl/textures
   */
  function getBytesPerElementForInternalFormat(internalFormat, type) {
    const info = getTextureInternalFormatInfo(internalFormat);
    if (!info) {
      throw "unknown internal format";
    }
    if (info.type) {
      const ndx = info.type.indexOf(type);
      if (ndx < 0) {
        throw new Error(`unsupported type ${type} for internalformat ${internalFormat}`);
      }
      return info.bytesPerElement[ndx];
    }
    return info.bytesPerElement[0];
  }

  function getBytesForMipUncompressed(internalFormat, width, height, depth, type) {
    const bytesPerElement = getBytesPerElementForInternalFormat(internalFormat, type);
    return width * height * depth * bytesPerElement;
  }

  function getBytesForMip(internalFormat, width, height, depth, type) {
    const fn = compressedTextureFunctions.get(internalFormat);
    return fn ? fn(width, height, depth) : getBytesForMipUncompressed(internalFormat, width, height, depth, type);
  }

  function isTypedArray(v) {
    return v && v.buffer && v.buffer instanceof ArrayBuffer;
  }

  function isBufferSource(v) {
    return isTypedArray(v) || v instanceof ArrayBuffer;
  }

  function getDrawingbufferInfo(gl) {
    return {
      samples: gl.getParameter(gl.SAMPLES) || 1,
      depthBits: gl.getParameter(gl.DEPTH_BITS),
      stencilBits: gl.getParameter(gl.STENCIL_BITS),
      contextAttributes: gl.getContextAttributes(),
    };
  }

  function computeDepthStencilSize(drawingBufferInfo) {
    const {depthBits, stencilBits} = drawingBufferInfo;
    const depthSize = (depthBits + stencilBits + 7) / 8 | 0;
    return depthSize === 3 ? 4 : depthSize;
  }

  function computeDrawingbufferSize(gl, drawingBufferInfo) {
    if (gl.isContextLost()) {
      return 0;
    }
    const {samples} = drawingBufferInfo;
    // this will need to change for hi-color support
    const colorSize = 4;
    const size = gl.drawingBufferWidth * gl.drawingBufferHeight;
    const depthStencilSize = computeDepthStencilSize(drawingBufferInfo);
    return size * colorSize + size * samples * colorSize + size * depthStencilSize;
  }

  // I know this is not a full check
  function isNumber(v) {
    return typeof v === 'number';
  }

  function collectObjects(state, type) {
    const list = [...state.webglObjectToMemory.keys()]
      .filter(obj => obj instanceof type)
      .map((obj) => state.webglObjectToMemory.get(obj));

    return list;
  }

  function getStackTrace() {
    const stack = (new Error()).stack;
    const lines = stack.split('\n');
    // Remove the first two entries, the error message and this function itself, or the webgl-memory itself.
    const userLines = lines.slice(2).filter((l) => !l.includes('webgl-memory.js'));
    return userLines.join('\n');
  }

  /*
  The MIT License (MIT)

  Copyright (c) 2021 Gregg Tavares

  Permission is hereby granted, free of charge, to any person obtaining a copy of
  this software and associated documentation files (the "Software"), to deal in
  the Software without restriction, including without limitation the rights to
  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  the Software, and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */


  //------------ [ from https://github.com/KhronosGroup/WebGLDeveloperTools ]

  /*
  ** Copyright (c) 2012 The Khronos Group Inc.
  **
  ** Permission is hereby granted, free of charge, to any person obtaining a
  ** copy of this software and/or associated documentation files (the
  ** "Materials"), to deal in the Materials without restriction, including
  ** without limitation the rights to use, copy, modify, merge, publish,
  ** distribute, sublicense, and/or sell copies of the Materials, and to
  ** permit persons to whom the Materials are furnished to do so, subject to
  ** the following conditions:
  **
  ** The above copyright notice and this permission notice shall be included
  ** in all copies or substantial portions of the Materials.
  **
  ** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  ** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  ** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  ** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  ** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  ** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
  */


  const augmentedSet = new Set();

  /**
   * Given a WebGL context replaces all the functions with wrapped functions
   * that call gl.getError after every command
   *
   * @param {WebGLRenderingContext|Extension} ctx The webgl context to wrap.
   * @param {string} nameOfClass (eg, webgl, webgl2, OES_texture_float)
   */
  // eslint-disable-next-line consistent-return
  function augmentAPI(ctx, nameOfClass, options = {}) {

    if (augmentedSet.has(ctx)) {
      return ctx;
    }
    augmentedSet.add(ctx);

    const origGLErrorFn = options.origGLErrorFn || ctx.getError;

    function createSharedState(ctx) {
      const drawingBufferInfo = getDrawingbufferInfo(ctx);
      const sharedState = {
        baseContext: ctx,
        config: options,
        apis: {
          // custom extension
          gman_webgl_memory: {
            ctx: {
              getMemoryInfo() {
                const drawingbuffer = computeDrawingbufferSize(ctx, drawingBufferInfo);
                return {
                  memory: {
                    ...memory,
                    drawingbuffer,
                    total: drawingbuffer + memory.buffer + memory.texture + memory.renderbuffer,
                  },
                  resources: {
                    ...resources,
                  },
                };
              },
              getResourcesInfo(type) {
                return collectObjects(sharedState, type);
              },
            },
          },
        },
        resources: {},
        memory: {
          texture: 0,
          buffer: 0,
          renderbuffer: 0,
        },
        bindings: new Map(),
        defaultVertexArray: {},
        webglObjectToMemory: new Map(),
      };

      const unRestorableAPIs = new Set([
        'webgl',
        'webgl2',
        'webgl_lose_context',
      ]);

      function resetSharedState() {
        sharedState.bindings.clear();
        sharedState.webglObjectToMemory.clear();
        sharedState.webglObjectToMemory.set(sharedState.defaultVertexArray, {});
        sharedState.currentVertexArray = sharedState.defaultVertexArray;
        [sharedState.resources, sharedState.memory].forEach(function(obj) {
          for (const prop in obj) {
            obj[prop] = 0;
          }
        });
      }

      function handleContextLost() {
        // Issues:
        //   * all resources are lost.
        //     Solution: handled by resetSharedState
        //   * all functions are no-op
        //     Solutions:
        //        * swap all functions for noop
        //          (not so easy because some functions return values)
        //        * wrap all functions is a isContextLost check forwarder
        //          (slow? and same as above)
        //        * have each function manually check for context lost
        //          (simple but repetitive)
        //   * all extensions are lost
        //      Solution: For these we go through and restore all the functions
        //         on each extension
        resetSharedState();
        sharedState.isContextLost = true;

        // restore all original functions for extensions since
        // user will have to get new extensions.
        for (const [name, {ctx, origFuncs}] of [...Object.entries(sharedState.apis)]) {
          if (!unRestorableAPIs.has(name) && origFuncs) {
            augmentedSet.delete(ctx);
            for (const [funcName, origFn] of Object.entries(origFuncs)) {
              ctx[funcName] = origFn;
            }
            delete apis[name];
          }
        }
      }

      function handleContextRestored() {
        sharedState.isContextLost = false;
      }

      if (ctx.canvas) {
        ctx.canvas.addEventListener('webglcontextlost', handleContextLost);
        ctx.canvas.addEventListener('webglcontextrestored', handleContextRestored);
      }

      resetSharedState();
      return sharedState;
    }

    const sharedState = options.sharedState || createSharedState(ctx);
    options.sharedState = sharedState;

    const {
      apis,
      bindings,
      memory,
      resources,
      webglObjectToMemory,
    } = sharedState;

    const origFuncs = {};

    function noop() {
    }

    function makeCreateWrapper(ctx, typeName, _funcName) {
      const funcName = _funcName || `create${typeName[0].toUpperCase()}${typeName.substr(1)}`;
      if (!ctx[funcName]) {
        return null;
      }
      resources[typeName] = 0;
      return function(ctx, funcName, args, webglObj) {
        if (sharedState.isContextLost) {
          return;
        }
        ++resources[typeName];
        webglObjectToMemory.set(webglObj, {
          size: 0,
          stackCreated: getStackTrace(),
        });
      };
    }

    function makeDeleteWrapper(typeName, fn = noop, _funcName) {
      const funcName = _funcName || `delete${typeName[0].toUpperCase()}${typeName.substr(1)}`;
      if (!ctx[funcName]) {
        return null;
      }
      return function(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [obj] = args;
        const info = webglObjectToMemory.get(obj);
        if (info) {
          --resources[typeName];
          fn(obj, info);
          // TODO: handle resource counts
          webglObjectToMemory.delete(obj);
        }
      };
    }

    function updateRenderbuffer(target, samples, internalFormat, width, height) {
      if (sharedState.isContextLost) {
        return;
      }
      const obj = bindings.get(target);
      if (!obj) {
        throw new Error(`no renderbuffer bound to ${target}`);
      }
      const info = webglObjectToMemory.get(obj);
      if (!info) {
        throw new Error(`unknown renderbuffer ${obj}`);
      }

      const bytesForMip = getBytesForMip(internalFormat, width, height, 1);
      const newSize = bytesForMip * samples;

      memory.renderbuffer -= info.size;
      info.size = newSize;
      info.stackUpdated = getStackTrace();
      memory.renderbuffer += newSize;
    }

    const ELEMENT_ARRAY_BUFFER           = 0x8893;

    const UNSIGNED_BYTE                  = 0x1401;
    const TEXTURE_CUBE_MAP               = 0x8513;
    const TEXTURE_2D_ARRAY               = 0x8C1A;
    const TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
    const TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
    const TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
    const TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
    const TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
    const TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851A;

    const TEXTURE_BASE_LEVEL             = 0x813C;
    const TEXTURE_MAX_LEVEL              = 0x813D;

    const cubemapTargets = new Set([
      TEXTURE_CUBE_MAP_POSITIVE_X,
      TEXTURE_CUBE_MAP_NEGATIVE_X,
      TEXTURE_CUBE_MAP_POSITIVE_Y,
      TEXTURE_CUBE_MAP_NEGATIVE_Y,
      TEXTURE_CUBE_MAP_POSITIVE_Z,
      TEXTURE_CUBE_MAP_NEGATIVE_Z,
    ]);

    function isCubemapFace(target) {
      return cubemapTargets.has(target);
    }

    function getTextureInfo(target) {
      target = isCubemapFace(target) ? TEXTURE_CUBE_MAP : target;
      const obj = bindings.get(target);
      if (!obj) {
        throw new Error(`no texture bound to ${target}`);
      }
      const info = webglObjectToMemory.get(obj);
      if (!info) {
        throw new Error(`unknown texture ${obj}`);
      }
      return info;
    }

    function updateMipLevel(info, target, level, internalFormat, width, height, depth, type) {
      const oldSize = info.size;
      const newMipSize = getBytesForMip(internalFormat, width, height, depth, type);

      const faceNdx = isCubemapFace(target)
        ? target - TEXTURE_CUBE_MAP_POSITIVE_X
        : 0;

      info.mips = info.mips || [];
      info.mips[level] = info.mips[level] || [];
      const mipFaceInfo = info.mips[level][faceNdx] || {};
      info.size -= mipFaceInfo.size || 0;

      mipFaceInfo.size = newMipSize;
      mipFaceInfo.internalFormat = internalFormat;
      mipFaceInfo.type = type;
      mipFaceInfo.width = width;
      mipFaceInfo.height = height;
      mipFaceInfo.depth = depth;

      info.mips[level][faceNdx] = mipFaceInfo;
      info.size += newMipSize;

      memory.texture -= oldSize;
      memory.texture += info.size;

      info.stackUpdated = getStackTrace();
    }

    function updateTexStorage(target, levels, internalFormat, width, height, depth) {
      const info = getTextureInfo(target);
      const numFaces = target === TEXTURE_CUBE_MAP ? 6 : 1;
      const baseFaceTarget = target === TEXTURE_CUBE_MAP ? TEXTURE_CUBE_MAP_POSITIVE_X : target;
      for (let level = 0; level < levels; ++level) {
        for (let face = 0; face < numFaces; ++face) {
          updateMipLevel(info, baseFaceTarget + face, level, internalFormat, width, height, depth);
        }
        width = Math.ceil(Math.max(width / 2, 1));
        height = Math.ceil(Math.max(height / 2, 1));
        depth = target === TEXTURE_2D_ARRAY ? depth : Math.ceil(Math.max(depth / 2, 1));
      }
    }

    function handleBindVertexArray(gl, funcName, args) {
      if (sharedState.isContextLost) {
        return;
      }
      const [va] = args;
      sharedState.currentVertexArray = va ? va : sharedState.defaultVertexArray;
    }

    function handleBufferBinding(target, obj) {
      if (sharedState.isContextLost) {
        return;
      }
      switch (target) {
        case ELEMENT_ARRAY_BUFFER: {
            const info = webglObjectToMemory.get(sharedState.currentVertexArray);
            info.elementArrayBuffer = obj;
            break;
          }
        default:
          bindings.set(target, obj);
          break;
      }
    }

    const preChecks = {};
    const postChecks = {
      // WebGL1
      //   void bufferData(GLenum target, GLsizeiptr size, GLenum usage);
      //   void bufferData(GLenum target, [AllowShared] BufferSource? srcData, GLenum usage);
      // WebGL2:
      //   void bufferData(GLenum target, [AllowShared] ArrayBufferView srcData, GLenum usage, GLuint srcOffset,
      //                   optional GLuint length = 0);
      bufferData(gl, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, src, /* usage */, /*srcOffset = 0*/, length = undefined] = args;
        let obj;
        switch (target) {
          case ELEMENT_ARRAY_BUFFER:
            {
              const info = webglObjectToMemory.get(sharedState.currentVertexArray);
              obj = info.elementArrayBuffer;
            }
            break;
          default:
            obj = bindings.get(target);
            break;
        }
        if (!obj) {
          throw new Error(`no buffer bound to ${target}`);
        }
        let newSize = 0;
        if (length !== undefined) {
          newSize = length * src.BYTES_PER_ELEMENT;
        } else if (isBufferSource(src)) {
          newSize = src.byteLength;
        } else if (isNumber(src)) {
          newSize = src;
        } else {
          throw new Error(`unsupported bufferData src type ${src}`);
        }

        const info = webglObjectToMemory.get(obj);
        if (!info) {
          throw new Error(`unknown buffer ${obj}`);
        }

        memory.buffer -= info.size;
        info.size = newSize;
        info.stackUpdated = getStackTrace();
        memory.buffer += newSize;
      },

      bindVertexArray: handleBindVertexArray,
      bindVertexArrayOES: handleBindVertexArray,

      bindBuffer(gl, funcName, args) {
        const [target, obj] = args;
        handleBufferBinding(target, obj);
      },

      bindBufferBase(gl, funcName, args) {
        const [target, /*ndx*/, obj] = args;
        handleBufferBinding(target, obj);
      },

      bindBufferRange(gl, funcName, args) {
        const [target, /*ndx*/, obj, /*offset*/, /*size*/] = args;
        handleBufferBinding(target, obj);
      },

      bindRenderbuffer(gl, funcName, args) {
        if (sharedState.isContextLost) {
         return;
        }
        const [target, obj] = args;
        bindings.set(target, obj);
      },

      bindTexture(gl, funcName, args) {
        if (sharedState.isContextLost) {
         return;
        }
        const [target, obj] = args;
        bindings.set(target, obj);
      },

      // void gl.copyTexImage2D(target, level, internalformat, x, y, width, height, border);
      copyTexImage2D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, level, internalFormat, /*x*/, /*y*/, width, height, /*border*/] = args;
        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, 1, UNSIGNED_BYTE);
      },

      createBuffer: makeCreateWrapper(ctx, 'buffer'),
      createFramebuffer: makeCreateWrapper(ctx, 'framebuffer'),
      createRenderbuffer: makeCreateWrapper(ctx, 'renderbuffer'),
      createProgram: makeCreateWrapper(ctx, 'program'),
      createQuery: makeCreateWrapper(ctx, 'query'),
      createShader: makeCreateWrapper(ctx, 'shader'),
      createSampler: makeCreateWrapper(ctx, 'sampler'),
      createTexture: makeCreateWrapper(ctx, 'texture'),
      createTransformFeedback: makeCreateWrapper(ctx, 'transformFeedback'),
      createVertexArray: makeCreateWrapper(ctx, 'vertexArray'),
      createVertexArrayOES: makeCreateWrapper(ctx, 'vertexArray', 'createVertexArrayOES'),

      // WebGL 1:
      // void gl.compressedTexImage2D(target, level, internalformat, width, height, border, ArrayBufferView? pixels);
      //
      // Additionally available in WebGL 2:
      // read from buffer bound to gl.PIXEL_UNPACK_BUFFER
      // void gl.compressedTexImage2D(target, level, internalformat, width, height, border, GLsizei imageSize, GLintptr offset);
      // void gl.compressedTexImage2D(target, level, internalformat, width, height, border,
      //                              ArrayBufferView srcData, optional srcOffset, optional srcLengthOverride);
      compressedTexImage2D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, level, internalFormat, width, height] = args;
        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, 1, UNSIGNED_BYTE);
      },

      // read from buffer bound to gl.PIXEL_UNPACK_BUFFER
      // void gl.compressedTexImage3D(target, level, internalformat, width, height, depth, border, GLsizei imageSize, GLintptr offset);
      // void gl.compressedTexImage3D(target, level, internalformat, width, height, depth, border,
      //                              ArrayBufferView srcData, optional srcOffset, optional srcLengthOverride);
      compressedTexImage3D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, level, internalFormat, width, height, depth] = args;
        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, depth, UNSIGNED_BYTE);
      },

      deleteBuffer: makeDeleteWrapper('buffer', function(obj, info) {
        memory.buffer -= info.size;
      }),
      deleteFramebuffer: makeDeleteWrapper('framebuffer'),
      deleteProgram: makeDeleteWrapper('program'),
      deleteQuery: makeDeleteWrapper('query'),
      deleteRenderbuffer: makeDeleteWrapper('renderbuffer', function(obj, info) {
        memory.renderbuffer -= info.size;
      }),
      deleteSampler: makeDeleteWrapper('sampler'),
      deleteShader: makeDeleteWrapper('shader'),
      deleteSync: makeDeleteWrapper('sync'),
      deleteTexture: makeDeleteWrapper('texture', function(obj, info) {
        memory.texture -= info.size;
      }),
      deleteTransformFeedback: makeDeleteWrapper('transformFeedback'),
      deleteVertexArray: makeDeleteWrapper('vertexArray'),
      deleteVertexArrayOES: makeDeleteWrapper('vertexArray', noop, 'deleteVertexArrayOES'),

      fenceSync: function(ctx) {
        if (sharedState.isContextLost) {
          return undefined;
        }
        if (!ctx.fenceSync) {
          return undefined;
        }
        resources.sync = 0;
        return function(ctx, funcName, args, webglObj) {
          ++resources.sync;

          webglObjectToMemory.set(webglObj, {
            size: 0,
          });
        };
      }(ctx),

      generateMipmap(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target] = args;
        const info = getTextureInfo(target);
        const baseMipNdx = info.parameters ? info.parameters.get(TEXTURE_BASE_LEVEL) || 0 : 0;
        const maxMipNdx = info.parameters ? info.parameters.get(TEXTURE_MAX_LEVEL) || 1024 : 1024;
        const mipInfo = info.mips[baseMipNdx][0];
        let {width, height, depth} = mipInfo;
        const {internalFormat, type} = mipInfo;
        let level = baseMipNdx + 1;

        const numFaces = target === TEXTURE_CUBE_MAP ? 6 : 1;
        const baseFaceTarget = target === TEXTURE_CUBE_MAP ? TEXTURE_CUBE_MAP_POSITIVE_X : target;
        while (level <= maxMipNdx && !(width === 1 && height === 1 && (depth === 1 || target === TEXTURE_2D_ARRAY))) {
          width = Math.ceil(Math.max(width / 2, 1));
          height = Math.ceil(Math.max(height / 2, 1));
          depth = target === TEXTURE_2D_ARRAY ? depth : Math.ceil(Math.max(depth / 2, 1));
          for (let face = 0; face < numFaces; ++face) {
            updateMipLevel(info, baseFaceTarget + face, level, internalFormat, width, height, depth, type);
          }
          ++level;
        }
      },

      getSupportedExtensions(ctx, funcName, args, result) {
        if (sharedState.isContextLost) {
          return;
        }
        result.push('GMAN_webgl_memory');
      },

      // void gl.renderbufferStorage(target, internalFormat, width, height);
      // gl.RGBA4: 4 red bits, 4 green bits, 4 blue bits 4 alpha bits.
      // gl.RGB565: 5 red bits, 6 green bits, 5 blue bits.
      // gl.RGB5_A1: 5 red bits, 5 green bits, 5 blue bits, 1 alpha bit.
      // gl.DEPTH_COMPONENT16: 16 depth bits.
      // gl.STENCIL_INDEX8: 8 stencil bits.
      // gl.DEPTH_STENCIL
      renderbufferStorage(ctx, funcName, args) {
        const [target, internalFormat, width, height] = args;
        updateRenderbuffer(target, 1, internalFormat, width, height);
      },

      // void gl.renderbufferStorageMultisample(target, samples, internalFormat, width, height);
      renderbufferStorageMultisample(ctx, funcName, args) {
        const [target, samples, internalFormat, width, height] = args;
        updateRenderbuffer(target, samples, internalFormat, width, height);
      },

      texImage2D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        // WebGL1:
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, ArrayBufferView? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, ImageData? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, HTMLImageElement? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, HTMLCanvasElement? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, HTMLVideoElement? pixels);
        // void gl.texImage2D(target, level, internalformat, format, type, ImageBitmap? pixels// );

        // WebGL2:
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, GLintptr offset);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, HTMLCanvasElement source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, HTMLImageElement source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, HTMLVideoElement source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, ImageBitmap source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, ImageData source);
        // void gl.texImage2D(target, level, internalformat, width, height, border, format, type, ArrayBufferView srcData, srcOffset);
        const [target, level, internalFormat] = args;
        let width;
        let height;
        let type;
        if (args.length === 6) {
          const src = args[5];
          width = src.width;
          height = src.height;
          type = args[4];
        } else {
          width = args[3];
          height = args[4];
          type = args[7];
        }

        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, 1, type);
      },

      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, GLintptr offset);
      //
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, HTMLCanvasElement source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, HTMLImageElement source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, HTMLVideoElement source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, ImageBitmap source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, ImageData source);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, ArrayBufferView? srcData);
      // void gl.texImage3D(target, level, internalformat, width, height, depth, border, format, type, ArrayBufferView srcData, srcOffset);

      texImage3D(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, level, internalFormat, width, height, depth, /*border*/, /*format*/, type] = args;
        const info = getTextureInfo(target);
        updateMipLevel(info, target, level, internalFormat, width, height, depth, type);
      },

      texParameteri(ctx, funcName, args) {
        if (sharedState.isContextLost) {
          return;
        }
        const [target, pname, value] = args;
        const info = getTextureInfo(target);
        info.parameters = info.parameters || new Map();
        info.parameters.set(pname, value);
      },

      // void gl.texStorage2D(target, levels, internalformat, width, height);
      texStorage2D(ctx, funcName, args) {
        const [target, levels, internalFormat, width, height] = args;
        updateTexStorage(target, levels, internalFormat, width, height, 1);
      },

      // void gl.texStorage3D(target, levels, internalformat, width, height, depth);
      texStorage3D(ctx, funcName, args) {
        const [target, levels, internalFormat, width, height, depth] = args;
        updateTexStorage(target, levels, internalFormat, width, height, depth);
      },
    };

    const extraWrappers = {
      getExtension(ctx, propertyName) {
        if (sharedState.isContextLost) {
          return;
        }
        const origFn = ctx[propertyName];
        ctx[propertyName] = function(...args) {
          const extensionName = args[0].toLowerCase();
          const api = apis[extensionName];
          if (api) {
            return api.ctx;
          }
          const ext = origFn.call(ctx, ...args);
          if (ext) {
            augmentAPI(ext, extensionName, {...options, origGLErrorFn});
          }
          return ext;
        };
      },
    };

    // Makes a function that calls a WebGL function and then calls getError.
    function makeErrorWrapper(ctx, funcName) {
      const origFn = ctx[funcName];
      const preCheck = preChecks[funcName] || noop;
      const postCheck = postChecks[funcName] || noop;
      if (preCheck === noop && postChecks === noop) {
        return;
      }
      ctx[funcName] = function(...args) {
        preCheck(ctx, funcName, args);
        const result = origFn.call(ctx, ...args);
        postCheck(ctx, funcName, args, result);
        return result;
      };
      const extraWrapperFn = extraWrappers[funcName];
      if (extraWrapperFn) {
        extraWrapperFn(ctx, funcName, origGLErrorFn);
      }
    }

    // Wrap each function
    for (const propertyName in ctx) {
      if (typeof ctx[propertyName] === 'function') {
        origFuncs[propertyName] = ctx[propertyName];
        makeErrorWrapper(ctx, propertyName);
      }
    }

    apis[nameOfClass.toLowerCase()] = { ctx, origFuncs };
  }

  /*
  The MIT License (MIT)

  Copyright (c) 2021 Gregg Tavares

  Permission is hereby granted, free of charge, to any person obtaining a copy of
  this software and associated documentation files (the "Software"), to deal in
  the Software without restriction, including without limitation the rights to
  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  the Software, and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */


  function wrapGetContext(Ctor) {
    const oldFn = Ctor.prototype.getContext;
    Ctor.prototype.getContext = function(type, ...args) {
      const ctx = oldFn.call(this, type, ...args);
      // Using bindTexture to see if it's WebGL. Could check for instanceof WebGLRenderingContext
      // but that might fail if wrapped by debugging extension
      if (ctx && ctx.bindTexture) {
        const config = {};
        augmentAPI(ctx, type, config);
        ctx.getExtension('GMAN_webgl_memory');
      }
      return ctx;
    };
  }

  if (typeof HTMLCanvasElement !== 'undefined') {
    wrapGetContext(HTMLCanvasElement);
  }
  if (typeof OffscreenCanvas !== 'undefined') {
    wrapGetContext(OffscreenCanvas);
  }

}));

```


## tsconfig.json

```
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true,
    "esModuleInterop": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src", "vite-env.d.ts"]
}
```


## vite.config.ts

```
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    host: true, // Listen on all addresses
    open: true, // Auto-open browser
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
    minify: 'terser',
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  optimizeDeps: {
    include: [
      '@esotericsoftware/spine-pixi-v8',
      'pixi.js',
      'gsap',
      '@paralleldrive/cuid2',
    ],
  },
});
```


## vite.d.ts

```
declare module '*.md' {
    // "unknown" would be more detailed depends on how you structure frontmatter
    const attributes: Record<string, unknown>; 
  
    // When "Mode.TOC" is requested
    const toc: { level: string, content: string }[];
  
    // When "Mode.HTML" is requested
    const html: string;
  
    // When "Mode.RAW" is requested
    const raw: string
  
  
    // Modify below per your usage
    export { attributes, toc, html };
  }
```
